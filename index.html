<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LoRa Dataset Manager (Ultimate Edition)</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Cropper.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

    <style>
        /* FIX DE SCROLL: Estructura fija al 100% del viewport */
        html, body { 
            height: 100%; 
            width: 100%; 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #1a1a1a; 
            color: #e0e0e0; 
            font-family: 'Segoe UI', sans-serif; 
        }
        #root { height: 100%; width: 100%; position: absolute; top: 0; left: 0; overflow: hidden; }

        /* Scrollbars estilo Fluent */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #2c2c2c; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
        
        .fluent-input {
            background-color: #1e1e1e;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
            padding: 6px;
            color: white;
            transition: all 0.2s;
            width: 100%;
        }
        .fluent-input:focus { border-color: #0067c0; outline: none; background-color: #1a1a1a; }
        
        .fluent-btn {
            background-color: #3c3c3c;
            border: 1px solid #454545;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        .fluent-btn:hover:not(:disabled) { background-color: #484848; }
        .fluent-btn:active:not(:disabled) { background-color: #323232; transform: translateY(1px); }
        .fluent-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .fluent-btn-primary { background-color: #0067c0; border-color: #0067c0; }
        .fluent-btn-primary:hover:not(:disabled) { background-color: #1975c5; border-color: #1975c5; }

        .fluent-btn-danger { background-color: #3f1a1a; border-color: #5c1e1e; color: #ff8888; }
        .fluent-btn-danger:hover:not(:disabled) { background-color: #5c1e1e; }

        .fluent-btn-sm { padding: 2px 8px; font-size: 0.75rem; height: 24px; }
        
        .item-card { transition: background-color 0.15s, border-color 0.15s; border: 1px solid transparent; }
        .item-card.selected { background-color: #2a3a4a; border-color: #0067c0; }
        .item-card:hover:not(.selected) { background-color: #2d2d2d; }

        /* Checkbox Custom Style */
        input[type="checkbox"] {
            accent-color: #0067c0;
            cursor: pointer;
        }

        .resizer-v { width: 5px; background: #252525; cursor: col-resize; z-index: 10; flex-shrink: 0; }
        .resizer-v:hover, .resizer-v.dragging { background: #0067c0; }

        .resizer-h { 
            height: 8px; 
            background: #252525; 
            cursor: row-resize; 
            z-index: 10; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-shrink: 0; 
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        .resizer-h:hover, .resizer-h.dragging { background: #0067c0; }
        .resizer-h .grip { 
            width: 40px; 
            height: 4px; 
            background: #666; 
            border-radius: 2px; 
        }

        .checkerboard {
            background-image: linear-gradient(45deg, #252525 25%, transparent 25%), 
                              linear-gradient(-45deg, #252525 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #252525 75%), 
                              linear-gradient(-45deg, transparent 75%, #252525 75%);
            background-size: 20px 20px;
        }
        
        .cropper-view-box, .cropper-face { border-radius: 0; outline: 1px solid #0067c0; }
        .cropper-line { background-color: #0067c0; }
        .cropper-point { width: 12px; height: 12px; background-color: #0067c0; opacity: 0.9; border-radius: 50%; }
        
        .tag-draggable { cursor: grab; transition: transform 0.2s, box-shadow 0.2s; }
        .tag-draggable:active { cursor: grabbing; box-shadow: 0 5px 10px rgba(0,0,0,0.3); transform: scale(1.05); z-index: 50; }

        .modal-overlay { background-color: rgba(0,0,0,0.8); backdrop-filter: blur(4px); z-index: 50; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, Component, useCallback } = React;

        class ErrorBoundary extends Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError() { return { hasError: true }; }
            componentDidCatch(error, info) { console.error("Crash:", error, info); }
            render() {
                if (this.state.hasError) return <div className="h-full flex items-center justify-center text-red-400">‚ö†Ô∏è Error Cr√≠tico. <button onClick={()=>location.reload()} className="ml-2 underline">Recargar</button></div>;
                return this.props.children;
            }
        }

        const Icon = ({ name, size = 16, className }) => {
            const containerRef = useRef(null);
            useEffect(() => {
                if (containerRef.current && window.lucide) {
                    containerRef.current.innerHTML = '';
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    containerRef.current.appendChild(i);
                    window.lucide.createIcons({ root: containerRef.current, attrs: { class: className, width: size, height: size } });
                }
            }, [name, size, className]);
            return <span ref={containerRef} className="inline-flex shrink-0 items-center justify-center"></span>;
        };

        const computeImageHash = async (blobUrl) => {
            return new Promise((resolve) => {
                const img = new Image(); img.src = blobUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas'); canvas.width = 8; canvas.height = 8;
                    const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'medium';
                    ctx.drawImage(img, 0, 0, 8, 8);
                    const data = ctx.getImageData(0, 0, 8, 8).data;
                    let total = 0; for(let i=0; i<data.length; i+=4) total += (data[i] + data[i+1] + data[i+2]) / 3;
                    const avg = total / 64;
                    let hash = ""; for(let i=0; i<data.length; i+=4) hash += ((data[i] + data[i+1] + data[i+2]) / 3) > avg ? "1" : "0";
                    resolve({ hash, width: img.naturalWidth, height: img.naturalHeight });
                };
                img.onerror = () => resolve(null);
            });
        };

        const getHammingDistance = (hash1, hash2) => {
            let dist = 0; for(let i=0; i<hash1.length; i++) if(hash1[i] !== hash2[i]) dist++;
            return dist;
        };

        const levenshteinDistance = (a, b) => {
            const matrix = []; for(let i=0; i<=b.length; i++) matrix[i] = [i]; for(let j=0; j<=a.length; j++) matrix[0][j] = j;
            for(let i=1; i<=b.length; i++) for(let j=1; j<=a.length; j++) matrix[i][j] = b.charAt(i-1)==a.charAt(j-1) ? matrix[i-1][j-1] : Math.min(matrix[i-1][j-1]+1, Math.min(matrix[i][j-1]+1, matrix[i-1][j]+1));
            return matrix[b.length][a.length];
        };

        const convertImage = (fileUrl, format) => {
            return new Promise(resolve => {
                if (format === 'original') return resolve(null);
                const img = new Image(); img.src = fileUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    if (format === 'jpeg') { ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                    ctx.drawImage(img, 0, 0);
                    canvas.toBlob(blob => resolve({ blob, ext: '.' + (format === 'jpeg' ? 'jpg' : format) }), format === 'png' ? 'image/png' : 'image/jpeg', 0.95);
                };
                img.onerror = () => resolve(null);
            });
        };

        function App() {
            const [history, setHistory] = useState({ past: [], present: [], future: [] });
            const files = history.present;

            const setFiles = (newFilesOrUpdater) => {
                setHistory(curr => {
                    const newFiles = typeof newFilesOrUpdater === 'function' ? newFilesOrUpdater(curr.present) : newFilesOrUpdater;
                    const newPast = [...curr.past, curr.present].slice(-20);
                    return { past: newPast, present: newFiles, future: [] };
                });
            };

            const undo = useCallback(() => {
                setHistory(curr => {
                    if (curr.past.length === 0) return curr;
                    const previous = curr.past[curr.past.length - 1];
                    const newPast = curr.past.slice(0, -1);
                    return { past: newPast, present: previous, future: [curr.present, ...curr.future] };
                });
            }, []);

            useEffect(() => {
                const handleKeyDown = (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } };
                window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo]);

            useEffect(() => {
                const handleBeforeUnload = (e) => { if (files.length > 0) { const m = "‚ö†Ô∏è"; e.preventDefault(); e.returnValue = m; return m; } };
                window.addEventListener('beforeunload', handleBeforeUnload); return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [files.length]);

            const [isMobile, setIsMobile] = useState(window.innerWidth < 1024);
            const [showMobileTools, setShowMobileTools] = useState(false);

            useEffect(() => {
                const handleResize = () => setIsMobile(window.innerWidth < 1024);
                window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize);
            }, []);

            const [selectedIds, setSelectedIds] = useState(new Set());
            const [activeId, setActiveId] = useState(null);
            const [loading, setLoading] = useState(false);
            const [loadingMsg, setLoadingMsg] = useState("Cargando...");
            const [visibleLimit, setVisibleLimit] = useState(40);
            
            const [sidebarWidth, setSidebarWidth] = useState(300);
            const [editorWidth, setEditorWidth] = useState(380);
            const [previewHeight, setPreviewHeight] = useState(350);
            const [viewMode, setViewMode] = useState('list');
            const [sortMode, setSortMode] = useState('name_asc');
            const [filterStatus, setFilterStatus] = useState('all');
            
            const [filterText, setFilterText] = useState("");
            const [prefix, setPrefix] = useState("");
            const [triggerWord, setTriggerWord] = useState("");
            const [tagToDelete, setTagToDelete] = useState("");
            const [findText, setFindText] = useState("");
            const [replaceText, setReplaceText] = useState("");
            const [newTagInput, setNewTagInput] = useState("");

            const [isCropping, setIsCropping] = useState(false);
            const cropImgRef = useRef(null);
            const [cropperInstance, setCropperInstance] = useState(null);

            const isDraggingLeft = useRef(false);
            const isDraggingRight = useRef(false);
            const isDraggingPreview = useRef(false);
            const lastMousePos = useRef({ x: 0, y: 0 }); 
            
            const dragItem = useRef();
            const dragOverItem = useRef();
            const gridContainerRef = useRef(null);

            const [dupModalOpen, setDupModalOpen] = useState(false);
            const [dupGroups, setDupGroups] = useState([]); 
            const [dupChecking, setDupChecking] = useState(false);
            const [dupProgress, setDupProgress] = useState(0);
            const [bucketModalOpen, setBucketModalOpen] = useState(false);
            const [buckets, setBuckets] = useState({});
            const [consolidationModalOpen, setConsolidationModalOpen] = useState(false);
            const [tagStats, setTagStats] = useState([]);
            const [editedTagStats, setEditedTagStats] = useState({});
            const [typoModalOpen, setTypoModalOpen] = useState(false);
            const [typoCandidates, setTypoCandidates] = useState([]);
            const [exportModalOpen, setExportModalOpen] = useState(false);
            const [exportOptions, setExportOptions] = useState({ 
                buckets: false, 
                images: true, 
                text: true, 
                stats: false, 
                format: 'original',
                customName: '' // Nuevo campo para el nombre personalizado
            });
            const [exportProgress, setExportProgress] = useState(0); // Nuevo estado para el progreso de exportaci√≥n
            const [isExporting, setIsExporting] = useState(false); // Nuevo estado para saber si se est√° exportando

            const allUniqueTags = useMemo(() => {
                const counter = {}; files.forEach(f => f.tags.split(',').forEach(t => { const trimmed = t.trim(); if (trimmed) counter[trimmed] = (counter[trimmed] || 0) + 1; }));
                return Object.entries(counter).sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0])).map(([tag, count]) => ({ tag, count })); 
            }, [files]);

            const processedFiles = useMemo(() => {
                let res = files.filter(f => {
                    const matchesText = f.newName.toLowerCase().includes(filterText.toLowerCase()) || f.tags.toLowerCase().includes(filterText.toLowerCase());
                    let matchesStatus = true;
                    if (filterStatus === 'tagged') matchesStatus = f.tagCount > 0;
                    if (filterStatus === 'untagged') matchesStatus = f.tagCount === 0;
                    return matchesText && matchesStatus;
                });
                if (sortMode === 'name_desc') res.sort((a,b)=>b.newName.localeCompare(a.newName));
                else if (sortMode === 'tags_count') res.sort((a,b)=>b.tagCount-a.tagCount);
                else res.sort((a,b)=>a.newName.localeCompare(b.newName));
                return res;
            }, [files, filterText, sortMode, filterStatus]);
            const visibleFiles = processedFiles.slice(0, visibleLimit);

            useEffect(() => {
                const handleNav = (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    const keys = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];
                    if (!keys.includes(e.key)) return;
                    e.preventDefault(); if (processedFiles.length === 0) return;
                    
                    const currentIndex = processedFiles.findIndex(f => f.id === activeId);
                    let nextIndex = currentIndex;
                    if (viewMode === 'list') {
                        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') nextIndex = Math.min(currentIndex + 1, processedFiles.length - 1);
                        else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') nextIndex = Math.max(currentIndex - 1, 0);
                    } else {
                        let cols = 1;
                        if (gridContainerRef.current) { cols = Math.floor((gridContainerRef.current.clientWidth + 8) / 128); if (cols < 1) cols = 1; }
                        if (e.key === 'ArrowRight') nextIndex = currentIndex + 1;
                        else if (e.key === 'ArrowLeft') nextIndex = currentIndex - 1;
                        else if (e.key === 'ArrowDown') nextIndex = currentIndex + cols;
                        else if (e.key === 'ArrowUp') nextIndex = currentIndex - cols;
                        nextIndex = Math.max(0, Math.min(nextIndex, processedFiles.length - 1));
                    }
                    if (nextIndex !== currentIndex && nextIndex !== -1) {
                        const nextId = processedFiles[nextIndex].id; setActiveId(nextId); setSelectedIds(new Set([nextId]));
                        const el = document.getElementById(`file-${nextId}`); if(el) el.scrollIntoView({block: 'nearest'});
                    }
                };
                window.addEventListener('keydown', handleNav); return () => window.removeEventListener('keydown', handleNav);
            }, [activeId, processedFiles, viewMode]);

            const handleScroll = (e) => { if (e.target.scrollHeight - e.target.scrollTop - e.target.clientHeight < 300) setVisibleLimit(prev => Math.min(prev + 40, files.length)); };

            // --- UNIFIED DRAG HANDLER (Mouse & Touch) ---
            useEffect(() => {
                const handleMove = (clientX, clientY) => {
                    const dx = clientX - lastMousePos.current.x;
                    const dy = clientY - lastMousePos.current.y;
                    lastMousePos.current = { x: clientX, y: clientY };

                    if (isDraggingLeft.current) setSidebarWidth(w => Math.max(200, Math.min(600, w + dx))); 
                    if (isDraggingLeft.current) setSidebarWidth(Math.max(200, Math.min(600, clientX)));
                    if (isDraggingRight.current) setEditorWidth(Math.max(300, Math.min(800, window.innerWidth - clientX)));
                    if (isDraggingPreview.current) setPreviewHeight(p => Math.max(150, Math.min(800, p + dy)));
                };

                const onMouseMove = (e) => { if (isDraggingLeft.current || isDraggingRight.current || isDraggingPreview.current) { e.preventDefault(); handleMove(e.clientX, e.clientY); } };
                const onTouchMove = (e) => { if (isDraggingLeft.current || isDraggingRight.current || isDraggingPreview.current) { e.preventDefault(); const touch = e.touches[0]; handleMove(touch.clientX, touch.clientY); } };
                const onUp = () => { isDraggingLeft.current = isDraggingRight.current = isDraggingPreview.current = false; document.body.style.cursor = 'default'; };

                document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onUp);
                document.addEventListener('touchmove', onTouchMove, { passive: false }); document.addEventListener('touchend', onUp);
                return () => {
                    document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onUp);
                    document.removeEventListener('touchmove', onTouchMove); document.removeEventListener('touchend', onUp);
                };
            }, []);

            const startDrag = (e, type) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                lastMousePos.current = { x: clientX, y: clientY };
                if (type === 'left') isDraggingLeft.current = true;
                if (type === 'right') isDraggingRight.current = true;
                if (type === 'preview') isDraggingPreview.current = true;
                document.body.style.cursor = type === 'preview' ? 'row-resize' : 'col-resize';
            };

            const handleFolderSelect = async (e) => {
                setLoading(true); setLoadingMsg("Cargando..."); setHistory({ past: [], present: [], future: [] }); setSelectedIds(new Set()); setActiveId(null);
                await new Promise(r => setTimeout(r, 100));
                const fileList = Array.from(e.target.files);
                const imageFiles = fileList.filter(f => f.name.match(/\.(jpg|jpeg|png|webp)$/i));
                const textFiles = fileList.filter(f => f.name.endsWith('.txt'));
                const txtMap = new Map(); textFiles.forEach(f => txtMap.set(f.name, f));
                const newFilesData = [];
                try {
                    for (let img of imageFiles) {
                        const baseName = img.name.substring(0, img.name.lastIndexOf('.'));
                        let content = ""; const txtFile = txtMap.get(baseName + ".txt"); if (txtFile) content = await txtFile.text();
                        newFilesData.push({ id: Math.random().toString(36).substr(2, 9), file: img, url: URL.createObjectURL(img), originalName: img.name, newName: baseName, extension: img.name.substring(img.name.lastIndexOf('.')), tags: content, tagCount: content.split(',').filter(t => t.trim()).length, hash: null, width: 0, height: 0 });
                    }
                    newFilesData.sort((a, b) => a.originalName.localeCompare(b.originalName));
                    setHistory({ past: [], present: newFilesData, future: [] }); setVisibleLimit(40); setLoading(false);
                } catch (error) { console.error(error); alert("Error: " + error.message); setLoading(false); }
            };

            const handleZipSelect = async (e) => {
                const file = e.target.files[0]; if (!file) return;
                setLoading(true); setLoadingMsg("Descomprimiendo ZIP..."); setHistory({ past: [], present: [], future: [] }); setSelectedIds(new Set()); setActiveId(null);
                try {
                    const zip = await JSZip.loadAsync(file);
                    const newFilesData = []; const validExtensions = ['.png', '.jpg', '.jpeg', '.webp']; const imageEntries = []; const textMap = new Map();
                    zip.forEach((relativePath, zipEntry) => { if (!zipEntry.dir) { const lowerName = relativePath.toLowerCase(); const ext = '.' + lowerName.split('.').pop(); if (validExtensions.includes(ext)) { imageEntries.push({ path: relativePath, entry: zipEntry, ext }); } else if (ext === '.txt') { textMap.set(relativePath, zipEntry); } } });
                    for (let i = 0; i < imageEntries.length; i++) {
                        const { path, entry, ext } = imageEntries[i]; if (path.includes('__MACOSX') || path.startsWith('.')) continue;
                        const blob = await entry.async("blob"); const url = URL.createObjectURL(blob);
                        const fileName = path.split('/').pop(); const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
                        const txtPath = path.substring(0, path.lastIndexOf('.')) + ".txt"; let content = ""; const txtEntry = textMap.get(txtPath);
                        if (txtEntry) content = await txtEntry.async("string");
                        newFilesData.push({ id: Math.random().toString(36).substr(2, 9), file: new File([blob], fileName, { type: blob.type }), url: url, originalName: fileName, newName: baseName, extension: ext, tags: content, tagCount: content.split(',').filter(t => t.trim()).length, hash: null, width: 0, height: 0 });
                        if (i % 20 === 0) { setLoadingMsg(`Procesando ${Math.round((i / imageEntries.length) * 100)}%`); await new Promise(r => setTimeout(r, 0)); }
                    }
                    newFilesData.sort((a, b) => a.originalName.localeCompare(b.originalName)); setHistory({ past: [], present: newFilesData, future: [] }); setVisibleLimit(40); setLoading(false);
                } catch (error) { console.error(error); alert("Error ZIP: " + error.message); setLoading(false); }
            };

            const analyzeBuckets = async () => {
                setDupChecking(true); setDupProgress(0); const bucketMap = {}; const currentFiles = [...files];
                for (let i = 0; i < currentFiles.length; i++) {
                    const file = currentFiles[i];
                    if (file.width === 0) { await new Promise(resolve => { const img = new Image(); img.src = file.url; img.onload = () => { file.width = img.naturalWidth; file.height = img.naturalHeight; resolve(); }; img.onerror = resolve; }); }
                    if (file.width > 0) { const key = `${file.width}x${file.height}`; bucketMap[key] = (bucketMap[key] || 0) + 1; }
                    setDupProgress(Math.round(((i + 1) / currentFiles.length) * 100)); if (i % 20 === 0) await new Promise(r => setTimeout(r, 0));
                }
                setBuckets(bucketMap); setDupChecking(false); setBucketModalOpen(true);
            };

            const findDuplicates = async () => {
                setDupChecking(true); setDupProgress(0); const hashMap = {}; const currentFiles = [...files]; const THRESHOLD = 5; 
                for (let i = 0; i < currentFiles.length; i++) {
                    const file = currentFiles[i];
                    if (!file.hash) { const result = await computeImageHash(file.url); if (result) { file.hash = result.hash; file.width = result.width; file.height = result.height; } }
                    setDupProgress(Math.round(((i + 1) / currentFiles.length) * 50)); if (i % 5 === 0) await new Promise(r => setTimeout(r, 0)); 
                }
                const groups = []; const visited = new Set();
                for (let i = 0; i < currentFiles.length; i++) {
                    const fileA = currentFiles[i]; if (visited.has(fileA.id)) continue; const group = [fileA];
                    for (let j = i + 1; j < currentFiles.length; j++) {
                        const fileB = currentFiles[j]; if (visited.has(fileB.id)) continue;
                        if (fileA.hash && fileB.hash) { const dist = getHammingDistance(fileA.hash, fileB.hash); if (dist <= THRESHOLD) { group.push(fileB); visited.add(fileB.id); } }
                    }
                    if (group.length > 1) { groups.push(group); visited.add(fileA.id); }
                    setDupProgress(50 + Math.round(((i + 1) / currentFiles.length) * 50)); if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
                }
                setDupChecking(false); if (groups.length > 0) { setDupGroups(groups); setDupModalOpen(true); } else alert("¬°Genial! No se encontraron duplicados.");
            };

            const findTypos = () => {
                const tags = allUniqueTags; const candidates = [];
                for (let i = 0; i < tags.length; i++) {
                    for (let j = i + 1; j < tags.length; j++) {
                        const t1 = tags[i]; const t2 = tags[j];
                        if (Math.abs(t1.tag.length - t2.tag.length) > 2 || t1.tag.length < 4 || t2.tag.length < 4) continue; 
                        const dist = levenshteinDistance(t1.tag, t2.tag);
                        if (dist > 0 && dist <= 2) { const likelyCorrect = t1.count >= t2.count ? t1 : t2; const likelyWrong = t1.count < t2.count ? t1 : t2; candidates.push({ correct: likelyCorrect, wrong: likelyWrong }); }
                    }
                }
                if (candidates.length > 0) { setTypoCandidates(candidates); setTypoModalOpen(true); } else alert("No se encontraron typos obvios.");
            };

            const fixTypo = (candidate) => {
                setFiles(prev => prev.map(f => {
                    const tags = f.tags.split(',').map(t => t.trim());
                    if (tags.includes(candidate.wrong.tag)) { const newTags = tags.map(t => t === candidate.wrong.tag ? candidate.correct.tag : t); const uniqueTags = [...new Set(newTags)]; return { ...f, tags: uniqueTags.join(', '), tagCount: uniqueTags.length }; } return f;
                }));
                setTypoCandidates(prev => prev.filter(c => c.wrong.tag !== candidate.wrong.tag)); if (typoCandidates.length <= 1) setTypoModalOpen(false);
            };

            const resolveDuplicate = (fileToDelete) => {
                setFiles(prev => prev.filter(f => f.id !== fileToDelete.id));
                setDupGroups(prevGroups => { const newGroups = prevGroups.map(group => group.filter(f => f.id !== fileToDelete.id)).filter(group => group.length > 1); if (newGroups.length === 0) setDupModalOpen(false); return newGroups; });
            };

            const openConsolidation = () => { const stats = allUniqueTags; setTagStats(stats); setEditedTagStats({}); setConsolidationModalOpen(true); };
            const handleTagEditChange = (originalTag, newText) => setEditedTagStats(prev => ({ ...prev, [originalTag]: newText }));
            const applyConsolidation = () => {
                const changes = Object.entries(editedTagStats).filter(([oldT, newT]) => newT && newT !== oldT);
                if (changes.length === 0) { setConsolidationModalOpen(false); return; }
                const replaceMap = {}; changes.forEach(([oldT, newT]) => replaceMap[oldT] = newT);
                setFiles(prev => prev.map(f => {
                    const tags = f.tags.split(',').map(t => t.trim()).filter(t => t); let changed = false;
                    const newTags = tags.map(t => { if (replaceMap[t]) { changed = true; return replaceMap[t]; } return t; });
                    if (changed) { const uniqueTags = [...new Set(newTags)]; return { ...f, tags: uniqueTags.join(', '), tagCount: uniqueTags.length }; } return f;
                }));
                setConsolidationModalOpen(false); alert(`Consolidadas ${changes.length} etiquetas.`);
            };

            const openExport = () => {
                if (files.length === 0) return;
                let suggestedName = "Dataset";
                if (triggerWord) { suggestedName = triggerWord + " Dataset v1"; } 
                else if (allUniqueTags.length > 0) { suggestedName = allUniqueTags[0].tag + " Dataset v1"; }
                setExportOptions(prev => ({ ...prev, customName: suggestedName }));
                setExportModalOpen(true);
            };

            // --- EXPORTAR OPTIMIZADO PARA M√ìVILES (CRASH FIX) ---
            const executeExport = async () => {
                setIsExporting(true);
                setExportProgress(0);
                
                try {
                    const zip = new JSZip();
                    const counts = {};
                    
                    if (exportOptions.stats) {
                        const statsData = {
                            total_files: files.length,
                            unique_tags: allUniqueTags.length,
                            top_tags: allUniqueTags.slice(0, 50),
                            generated_at: new Date().toISOString()
                        };
                        zip.file("dataset_stats.json", JSON.stringify(statsData, null, 2));
                    }

                    if (exportOptions.buckets) {
                        for (const f of files) {
                            if (f.width === 0) {
                                await new Promise(resolve => {
                                    const img = new Image(); img.src = f.url;
                                    img.onload = () => { f.width = img.naturalWidth; f.height = img.naturalHeight; resolve(); };
                                    img.onerror = resolve;
                                });
                            }
                        }
                    }

                    // Bucle ralentizado para m√≥viles (Throttling)
                    for (let i = 0; i < files.length; i++) {
                        const f = files[i];
                        let n = f.newName;
                        if(counts[n]) n = `${n}_${++counts[n]}`; else counts[n]=1;
                        
                        let folderPrefix = "";
                        if (exportOptions.buckets && f.width > 0) {
                            folderPrefix = `${f.width}x${f.height}/`;
                        }

                        if (exportOptions.images) {
                            if (exportOptions.format === 'original') {
                                zip.file(`${folderPrefix}${n}${f.extension}`, f.file);
                            } else {
                                const converted = await convertImage(f.url, exportOptions.format);
                                if (converted) {
                                    zip.file(`${folderPrefix}${n}${converted.ext}`, converted.blob);
                                } else {
                                    zip.file(`${folderPrefix}${n}${f.extension}`, f.file);
                                }
                            }
                        }
                        if (exportOptions.text) zip.file(`${folderPrefix}${n}.txt`, f.tags);
                        
                        setExportProgress(Math.round(((i + 1) / files.length) * 100));
                        
                        // Pausa m√°s agresiva en m√≥viles para Garbage Collector
                        await new Promise(r => setTimeout(r, isMobile ? 50 : 0));
                    }

                    setLoadingMsg("Generando ZIP final...");
                    const compressionMethod = isMobile ? "STORE" : "DEFLATE"; // STORE es r√°pido y usa poca RAM
                    
                    const c = await zip.generateAsync({
                        type: "blob", 
                        compression: compressionMethod
                    });
                    
                    const a = document.createElement('a'); 
                    a.href = URL.createObjectURL(c); 
                    let finalName = exportOptions.customName.trim() || "dataset";
                    if (!finalName.toLowerCase().endsWith(".zip")) finalName += ".zip";
                    a.download = finalName; 
                    a.click();
                    
                } catch (err) {
                    alert("Error exportando (posible falta de memoria): " + err.message);
                } finally {
                    setIsExporting(false);
                    setExportModalOpen(false);
                }
            };

            useEffect(() => {
                if (isCropping && cropImgRef.current) { const cropper = new Cropper(cropImgRef.current, { viewMode: 1, dragMode: 'move', autoCropArea: 1, background: false, zoomable: true, scalable: true }); setCropperInstance(cropper); return () => cropper.destroy(); }
            }, [isCropping, activeId]); 
            const setCropRatio = (r) => cropperInstance && cropperInstance.setAspectRatio(r);
            const saveCrop = () => {
                if (!cropperInstance || !activeFile) return;
                cropperInstance.getCroppedCanvas().toBlob((blob) => {
                    const newUrl = URL.createObjectURL(blob); const baseName = activeFile.newName + "_crop";
                    const newFile = { ...activeFile, id: Math.random().toString(36).substr(2, 9), file: blob, url: newUrl, originalName: baseName + ".png", newName: baseName, extension: ".png", hash: null };
                    setFiles(prev => [...prev, newFile]); setIsCropping(false);
                });
            };

            const activeFile = useMemo(() => files.find(f => f.id === activeId), [files, activeId]);
            const getTargets = () => selectedIds.size > 0 ? files.filter(f => selectedIds.has(f.id)) : files;
            const updateFiles = (updater) => setFiles(prev => prev.map(updater));
            const updateActiveTags = (newTags) => { if (!activeId) return; const count = newTags.split(',').filter(t => t.trim()).length; setFiles(prev => prev.map(f => f.id === activeId ? { ...f, tags: newTags, tagCount: count } : f)); };
            const handleTagSort = () => { if (!activeFile) return; const tagsArray = activeFile.tags.split(',').map(t => t.trim()).filter(t => t); const dragged = tagsArray[dragItem.current]; tagsArray.splice(dragItem.current, 1); tagsArray.splice(dragOverItem.current, 0, dragged); dragItem.current = null; dragOverItem.current = null; updateActiveTags(tagsArray.join(', ')); };
            const addTag = () => { if (!activeId || !newTagInput.trim()) return; const current = activeFile.tags.split(',').map(t => t.trim()).filter(t => t); if (!current.includes(newTagInput.trim())) updateActiveTags([...current, newTagInput.trim()].join(', ')); setNewTagInput(""); };
            const removeTag = (tag) => { const current = activeFile.tags.split(',').map(t => t.trim()); updateActiveTags(current.filter(t => t !== tag).join(', ')); };
            const batchRename = () => { if (!prefix) return; const ids = new Set(getTargets().map(f => f.id)); let c = 1; updateFiles(f => ids.has(f.id) ? { ...f, newName: `${prefix}_${String(c++).padStart(3, '0')}` } : f); };
            
            // --- FIX FOR TRIGGER WORD UPDATE & TAG COUNTS ---
            const addTrigger = () => {
                if (!triggerWord) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim()).filter(t => t);
                        if (!tags.includes(triggerWord)) {
                            const newTags = [triggerWord, ...tags];
                            return { ...f, tags: newTags.join(', '), tagCount: newTags.length };
                        }
                    }
                    return f;
                });
            };

            const deleteTag = () => {
                if (!tagToDelete) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim()).filter(t => t.toLowerCase() !== tagToDelete.toLowerCase());
                        return { ...f, tags: tags.join(', '), tagCount: tags.length };
                    }
                    return f;
                });
            };
            
            const searchRep = () => {
                if (!findText) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim() === findText ? replaceText : t.trim()).filter(t => t);
                        return { ...f, tags: tags.join(', '), tagCount: tags.length };
                    }
                    return f;
                });
            };

            const deleteSelected = () => { const targets = getTargets(); if (!targets.length || !confirm(`¬øBorrar ${targets.length} im√°genes?`)) return; const ids = new Set(targets.map(f => f.id)); if (activeId && ids.has(activeId)) { setActiveId(null); setIsCropping(false); } setFiles(prev => prev.filter(f => !ids.has(f.id))); setSelectedIds(new Set()); };
            
            // --- NEW CLEAR ALL TAGS FUNCTION ---
            const clearAllTags = () => {
                const targets = getTargets();
                if (targets.length === 0) return;
                if (!confirm(`¬øBorrar todas las etiquetas de ${targets.length} im√°genes?`)) return;
                const ids = new Set(targets.map(f => f.id));
                updateFiles(f => ids.has(f.id) ? { ...f, tags: '', tagCount: 0 } : f);
            };

            const dedupTags = () => { const ids = new Set(getTargets().map(f => f.id)); let changes = 0; const newF = files.map(f => { if (ids.has(f.id)) { const tags = f.tags.split(',').map(t=>t.trim()).filter(t=>t); const seen = new Set(); const unique = tags.filter(t => { const l = t.toLowerCase(); if(seen.has(l)) return false; seen.add(l); return true; }); if (unique.length !== tags.length) { changes++; return { ...f, tags: unique.join(', '), tagCount: unique.length }; } } return f; }); if (changes) { setFiles(newF); alert(`Corregidos ${changes} archivos.`); } else alert("Sin duplicados."); };
            
            const handleSelect = (id, multi) => { const newS = new Set(multi ? selectedIds : []); if (newS.has(id)) newS.delete(id); else newS.add(id); setSelectedIds(newS); if (!multi || newS.size === 1) { setActiveId(id); setIsCropping(false); } };

            const LeftPanelContent = (
                <>
                    <div className="p-4 border-b border-[#3e3e3e] flex-shrink-0">
                        {isMobile && <div className="flex justify-between items-center mb-4"><h1 className="font-bold text-lg text-white flex items-center gap-2"><Icon name="layers"/> Herramientas</h1><button onClick={() => setShowMobileTools(false)} className="fluent-btn">Cerrar</button></div>}
                        {!isMobile && <h1 className="font-bold text-lg text-white mb-2 flex items-center gap-2"><Icon name="layers" /> Dataset Manager</h1>}
                        <div className="flex gap-2">
                            <label className={`fluent-btn fluent-btn-primary flex-1 block text-center cursor-pointer ${loading ? 'opacity-50 pointer-events-none' : ''}`}>{loading ? "..." : "üìÇ Carpeta"}<input type="file" webkitdirectory="true" multiple className="hidden" onChange={handleFolderSelect} disabled={loading} /></label>
                            <label className={`fluent-btn flex-1 block text-center cursor-pointer ${loading ? 'opacity-50 pointer-events-none' : ''}`}>üì¶ ZIP<input type="file" accept=".zip" className="hidden" onChange={handleZipSelect} disabled={loading} /></label>
                        </div>
                        <div className="text-xs text-gray-400 mt-2 text-center flex justify-between"><span>Total: {files.length}</span>{history.past.length > 0 && <span className="text-gray-500 font-bold" title="Ctrl+Z para deshacer">‚Ü© Deshacer</span>}</div>
                    </div>
                    <div className="flex-1 overflow-y-auto p-4 space-y-4 min-h-0">
                        <div className="flex gap-2"><button onClick={()=>{setSelectedIds(new Set(files.map(f=>f.id)))}} className="fluent-btn flex-1">Todo</button><button onClick={()=>{setSelectedIds(new Set())}} className="fluent-btn flex-1">Nada</button></div>
                        <div className="space-y-2 pt-2 border-t border-[#3e3e3e]">
                            <p className="text-xs font-bold text-gray-500 uppercase">Edici√≥n de Tags</p>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Renombrar archivos..." value={prefix} onChange={e=>setPrefix(e.target.value)} /><button onClick={batchRename} className="fluent-btn"><Icon name="edit-3" size={14}/></button></div>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Trigger..." value={triggerWord} onChange={e=>setTriggerWord(e.target.value)} /><button onClick={addTrigger} className="fluent-btn"><Icon name="plus" size={14}/></button></div>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Borrar tag..." value={tagToDelete} onChange={e=>setTagToDelete(e.target.value)} /><button onClick={deleteTag} className="fluent-btn text-red-400"><Icon name="trash-2" size={14}/></button></div>
                            <div className="space-y-2"><input className="fluent-input" placeholder="Buscar..." value={findText} onChange={e=>setFindText(e.target.value)}/><div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Reemplazo..." value={replaceText} onChange={e=>setReplaceText(e.target.value)} /><button onClick={searchRep} className="fluent-btn">OK</button></div></div>
                            <button onClick={clearAllTags} className="fluent-btn w-full justify-start gap-2 text-red-400 hover:text-red-300 hover:bg-red-900/20 mt-1"><Icon name="eraser" size={14}/> Limpiar Etiquetas</button>
                        </div>
                        <div className="space-y-2 pt-2 border-t border-[#3e3e3e]">
                            <p className="text-xs font-bold text-gray-500 uppercase">Herramientas</p>
                            <button onClick={findTypos} className="fluent-btn w-full justify-start gap-2 text-yellow-300 hover:text-yellow-100"><Icon name="search" size={14}/> üîç Detectar Typos</button>
                            <button onClick={dedupTags} className="fluent-btn w-full justify-start gap-2"><Icon name="scissors" size={14}/> Dedup Tags</button>
                            <button onClick={deleteSelected} className="fluent-btn fluent-btn-danger w-full justify-start gap-2"><Icon name="trash" size={14}/> Eliminar (Img+Txt)</button>
                            <button onClick={openConsolidation} className="fluent-btn w-full justify-start gap-2 text-purple-300 hover:text-purple-100"><Icon name="puzzle" size={14}/> üß© Consolidar Tags</button>
                            <button onClick={analyzeBuckets} className="fluent-btn w-full justify-start gap-2 text-blue-200 hover:text-blue-100"><Icon name="monitor" size={14}/> üìä Buckets</button>
                            <div className="flex flex-col gap-1">
                                <button onClick={findDuplicates} disabled={dupChecking} className="fluent-btn w-full justify-start gap-2 bg-[#4a3a1a] border-[#665522] text-[#ffdd88] hover:bg-[#665522]">
                                    <Icon name="copy" size={14}/> Detect Duplicate Images
                                </button>
                                {dupChecking && (
                                    <div className="w-full h-1.5 bg-[#222] rounded-full overflow-hidden">
                                        <div className="h-full bg-[#ffdd88] transition-all duration-300" style={{width: `${dupProgress}%`}}></div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                    <div className="p-4 border-t border-[#3e3e3e] flex-shrink-0"><button onClick={openExport} className="fluent-btn fluent-btn-primary w-full py-3 font-bold flex justify-center gap-2" disabled={!files.length}><Icon name="download"/> Exportar ZIP</button></div>
                </>
            );

            const CenterPanelContent = (
                <>
                    <div className="p-2 border-b border-[#3e3e3e] flex-shrink-0">
                        {isMobile ? (
                            // Mobile Layout: Column
                            <div className="flex flex-col gap-2">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => setShowMobileTools(true)} className="fluent-btn flex-shrink-0"><Icon name="menu"/></button>
                                    <div className="flex-1 flex items-center bg-[#1e1e1e] border border-[#3e3e3e] rounded px-2">
                                        <Icon name="search" className="text-gray-400 flex-shrink-0"/>
                                        <input className="fluent-input bg-transparent border-none flex-1 p-2" placeholder="Filtrar..." list="tag-suggestions" value={filterText} onChange={e=>setFilterText(e.target.value)}/>
                                    </div>
                                </div>
                                <div className="flex items-center gap-2 overflow-x-auto no-scrollbar">
                                    <select className="bg-[#333] text-white text-xs p-2 rounded border-none outline-none flex-shrink-0" value={filterStatus} onChange={e=>setFilterStatus(e.target.value)}>
                                        <option value="all">Todos</option>
                                        <option value="tagged">Con Tags</option>
                                        <option value="untagged">Sin Tags</option>
                                    </select>
                                    <select className="bg-[#333] text-white text-xs p-2 rounded border-none outline-none flex-shrink-0" value={sortMode} onChange={e=>setSortMode(e.target.value)}>
                                        <option value="name_asc">A-Z</option>
                                        <option value="name_desc">Z-A</option>
                                        <option value="tags_count"># Tags</option>
                                    </select>
                                    <div className="flex bg-[#333] rounded p-0.5 flex-shrink-0 ml-auto">
                                        <button className={`p-1.5 rounded ${viewMode==='list'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('list')}><Icon name="list" size={16}/></button>
                                        <button className={`p-1.5 rounded ${viewMode==='grid'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('grid')}><Icon name="grid" size={16}/></button>
                                        <button className="p-1.5 rounded text-red-400 hover:bg-red-900/30 hover:text-red-200 ml-1 border-l border-[#444]" onClick={deleteSelected} title="Eliminar Seleccionados" disabled={selectedIds.size === 0}><Icon name="trash" size={16}/></button>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            // Desktop Layout: Row (Original)
                            <div className="flex items-center gap-2">
                                <Icon name="search" className="text-gray-400"/>
                                <input className="fluent-input bg-transparent border-none flex-1" placeholder="Filtrar..." list="tag-suggestions" value={filterText} onChange={e=>setFilterText(e.target.value)}/>
                                <select className="bg-[#333] text-white text-xs p-1 rounded border-none outline-none" value={filterStatus} onChange={e=>setFilterStatus(e.target.value)}>
                                    <option value="all">Todos</option>
                                    <option value="tagged">Con Etiquetas</option>
                                    <option value="untagged">Sin Etiquetas</option>
                                </select>
                                <select className="bg-[#333] text-white text-xs p-1 rounded border-none outline-none" value={sortMode} onChange={e=>setSortMode(e.target.value)}>
                                    <option value="name_asc">A-Z</option>
                                    <option value="name_desc">Z-A</option>
                                    <option value="tags_count"># Tags</option>
                                </select>
                                <div className="flex bg-[#333] rounded p-0.5">
                                    <button className={`p-1.5 rounded ${viewMode==='list'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('list')}><Icon name="list" size={16}/></button>
                                    <button className={`p-1.5 rounded ${viewMode==='grid'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('grid')}><Icon name="grid" size={16}/></button>
                                    <button className="p-1.5 rounded text-red-400 hover:bg-red-900/30 hover:text-red-200 ml-1 border-l border-[#444]" onClick={deleteSelected} title="Eliminar Seleccionados" disabled={selectedIds.size === 0}><Icon name="trash" size={16}/></button>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 min-h-0" onScroll={handleScroll}>
                        {!files.length && !loading && <div className="h-full flex flex-col items-center justify-center text-gray-500"><Icon name="folder-open" size={48} className="mb-4 opacity-50"/><p>Sube una carpeta o ZIP</p></div>}
                        {loading && <div className="h-full flex flex-col items-center justify-center text-blue-400 animate-pulse"><p className="font-bold">{loadingMsg}</p></div>}
                        <div ref={gridContainerRef} className={viewMode==='grid'?"grid grid-cols-[repeat(auto-fill,minmax(120px,1fr))] gap-2":"flex flex-col gap-1"}>
                            {visibleFiles.map(f => (
                                <div key={f.id} id={`file-${f.id}`} onClick={(e)=>handleSelect(f.id, e.ctrlKey||e.metaKey)} className={`item-card rounded cursor-pointer relative overflow-hidden group ${viewMode==='grid'?'aspect-[3/4] flex flex-col bg-[#252525]':'flex items-center gap-3 p-2 border-b border-[#2a2a2a]'} ${selectedIds.has(f.id)?'selected':''}`}>
                                    <div className={viewMode==='grid' ? "absolute top-2 left-2 z-20" : ""} onClick={(e)=>e.stopPropagation()}>
                                        <input type="checkbox" checked={selectedIds.has(f.id)} onChange={()=>handleSelect(f.id, true)} className="w-5 h-5 accent-[#0067c0] cursor-pointer drop-shadow-md border border-white/20 rounded-sm"/>
                                    </div>
                                    <div className={`${viewMode==='grid'?'flex-1 w-full':'w-12 h-12'} bg-black overflow-hidden relative`}>
                                        <img src={f.url} className="w-full h-full object-contain" draggable="false" loading="lazy" />
                                        {selectedIds.has(f.id) && <div className="absolute top-1 right-1 bg-[#0067c0] text-white rounded-full p-0.5"><Icon name="check" size={12}/></div>}
                                    </div>
                                    <div className={`${viewMode==='grid'?'p-2 text-center text-xs h-12':'flex-1 min-w-0'}`}>
                                        <div className="font-bold text-white truncate" title={f.newName}>{f.newName}</div>
                                        <div className="text-xs text-gray-500 truncate">{f.tagCount} tags</div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </>
            );

            const RightPanelContent = activeFile ? (
                <>
                    <div className="p-4 border-b border-[#3e3e3e] bg-[#252525] flex-shrink-0">
                        {isMobile && <div className="flex items-center mb-4"><button onClick={() => setActiveId(null)} className="fluent-btn w-full">‚¨Ö Volver a la Galer√≠a</button></div>}
                        <div className="flex justify-between items-center mb-2">
                            <h2 className="font-bold text-xs uppercase text-gray-500">Vista Previa</h2>
                            {isCropping ? <div className="flex gap-1"><button onClick={()=>setCropRatio(NaN)} className="fluent-btn fluent-btn-sm">Libre</button><button onClick={()=>setCropRatio(1)} className="fluent-btn fluent-btn-sm">1:1</button><button onClick={()=>setCropRatio(2/3)} className="fluent-btn fluent-btn-sm">2:3</button><button onClick={()=>setCropRatio(3/2)} className="fluent-btn fluent-btn-sm">3:2</button><button onClick={saveCrop} className="fluent-btn fluent-btn-sm bg-[#0067c0]">Guardar</button><button onClick={()=>setIsCropping(false)} className="text-xs text-gray-400 hover:text-white px-2">X</button></div> : <button onClick={()=>setIsCropping(true)} className="text-xs flex gap-1 items-center hover:text-white text-gray-400"><Icon name="crop" size={12}/> Recortar</button>}
                        </div>
                        
                        {/* IMAGEN PREVIEW RESIZABLE CON HANDLE */}
                        <div style={{height: previewHeight}} className="w-full bg-[#1a1a1a] border border-[#3e3e3e] flex items-center justify-center overflow-hidden relative checkerboard">
                            {isCropping ? <img ref={cropImgRef} src={activeFile.url} className="max-w-full block" /> : <img src={activeFile.url} className="w-full h-full object-contain" />}
                        </div>
                        <div className="resizer-h mt-1 mb-2" onMouseDown={(e) => startDrag(e, 'preview')} onTouchStart={(e) => startDrag(e, 'preview')}><div className="grip"></div></div>
                        
                        <div className="text-xs text-gray-400 text-center select-text">{activeFile.originalName}</div>
                    </div>
                    <div className="flex-1 p-4 overflow-y-auto flex flex-col gap-4 min-h-0">
                        <div><label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Nombre</label><input className="fluent-input" value={activeFile.newName} onChange={e=>updateFiles(f=>f.id===activeId?{...f,newName:e.target.value}:f)} /></div>
                        <div>
                            <label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Etiquetas (Arrastrables)</label>
                            <div className="flex gap-2 mb-2"><input className="fluent-input flex-1" placeholder="A√±adir..." list="tag-suggestions" value={newTagInput} onChange={e=>setNewTagInput(e.target.value)} onKeyDown={e=>e.key==='Enter'&&addTag()}/><button onClick={addTag} className="fluent-btn text-lg leading-none">+</button></div>
                            <div className="flex flex-wrap gap-1 bg-[#1a1a1a] p-2 rounded min-h-[60px] content-start">
                                {activeFile.tags.split(',').map(t=>t.trim()).filter(t=>t).map((tag, i)=>(<span key={i} className="bg-[#3a3a3a] border border-[#555] text-white text-xs px-2 py-1 rounded flex items-center gap-1 group hover:border-[#0067c0] tag-draggable" draggable onDragStart={()=>dragItem.current=i} onDragEnter={()=>dragOverItem.current=i} onDragEnd={handleTagSort} onDragOver={e=>e.preventDefault()}>{tag}<button onClick={()=>removeTag(tag)} className="hover:text-red-300 opacity-50 group-hover:opacity-100 ml-1">√ó</button></span>))}
                            </div>
                        </div>
                        <div><label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Raw Text</label><textarea className="fluent-input h-32 font-mono text-xs" value={activeFile.tags} onChange={e=>updateActiveTags(e.target.value)}></textarea></div>
                    </div>
                </>
            ) : <div className="flex-1 flex flex-col items-center justify-center text-gray-500 p-8 text-center"><Icon name="mouse-pointer-2" size={32} className="mb-2 opacity-50"/><p>Selecciona una imagen</p></div>;

            return (
                <div className="flex h-full w-full overflow-hidden text-sm select-none">
                    <datalist id="tag-suggestions">{allUniqueTags.map(({tag, count}) => <option key={tag} value={tag} label={`${tag} (${count})`} />)}</datalist>
                    {isMobile ? (
                        <div className="flex flex-col w-full h-full bg-[#1a1a1a]">
                            {activeFile ? <div className="flex-1 flex flex-col h-full overflow-hidden">{RightPanelContent}</div> : showMobileTools ? <div className="flex-1 flex flex-col bg-[#2c2c2c] h-full overflow-hidden">{LeftPanelContent}</div> : <div className="flex-1 flex flex-col h-full overflow-hidden">{CenterPanelContent}</div>}
                        </div>
                    ) : (
                        <>
                            <div className="bg-[#2c2c2c] flex flex-col border-r border-[#3e3e3e] h-full overflow-hidden" style={{ width: sidebarWidth }}>{LeftPanelContent}</div>
                            <div className="resizer-v" onMouseDown={(e) => startDrag(e, 'left')} onTouchStart={(e) => startDrag(e, 'left')}></div>
                            <div className="flex-1 bg-[#202020] flex flex-col min-w-0 h-full overflow-hidden">{CenterPanelContent}</div>
                            <div className="resizer-v" onMouseDown={(e) => startDrag(e, 'right')} onTouchStart={(e) => startDrag(e, 'right')}></div>
                            <div className="bg-[#2c2c2c] border-l border-[#3e3e3e] flex flex-col h-full overflow-hidden" style={{ width: editorWidth }}>{RightPanelContent}</div>
                        </>
                    )}
                    {/* Modales (mismo c√≥digo que antes) */}
                    {dupModalOpen && dupGroups.length > 0 && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-5xl h-[80vh] flex flex-col">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="copy" /> Conflictos: {dupGroups.length} grupos</h2><button onClick={() => setDupModalOpen(false)} className="fluent-btn">Cerrar</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-6">{dupGroups.map((group, gIdx) => (<div key={gIdx} className="bg-[#1a1a1a] p-4 rounded border border-[#333]"><div className="flex gap-4 overflow-x-auto pb-2">{group.map(file => (<div key={file.id} className="flex-1 min-w-[200px] bg-[#252525] p-3 rounded border border-[#333] flex flex-col gap-2"><div className="h-40 bg-black flex items-center justify-center rounded overflow-hidden"><img src={file.url} className="max-w-full max-h-full object-contain" /></div><div className="text-xs space-y-1"><div className="font-bold text-white truncate">{file.originalName}</div><div className="text-gray-400">{file.width}x{file.height}</div></div><button onClick={() => resolveDuplicate(file)} className="fluent-btn fluent-btn-danger w-full mt-auto"><Icon name="trash" size={14}/> Eliminar</button></div>))}</div></div>))}</div>
                            </div>
                        </div>
                    )}
                    {typoModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-3xl flex flex-col max-h-[80vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="search" /> Posibles Errores ({typoCandidates.length})</h2><button onClick={() => setTypoModalOpen(false)} className="fluent-btn">Cerrar</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-3">{typoCandidates.map((c, i) => (<div key={i} className="flex items-center justify-between bg-[#333] p-3 rounded border border-[#444]"><div className="flex items-center gap-4"><div className="text-right"><div className="text-red-400 font-bold strike">{c.wrong.tag}</div><div className="text-xs text-gray-500">({c.wrong.count} usos)</div></div><Icon name="arrow-right" className="text-gray-500" /><div><div className="text-green-400 font-bold">{c.correct.tag}</div><div className="text-xs text-gray-500">({c.correct.count} usos)</div></div></div><button onClick={() => fixTypo(c)} className="fluent-btn fluent-btn-primary">Corregir</button></div>))}</div>
                            </div>
                        </div>
                    )}
                    {exportModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-md p-6">
                                <h2 className="text-xl font-bold text-white mb-4">Opciones de Exportaci√≥n</h2>
                                <div className="space-y-4 mb-6">
                                    <div className="bg-[#333] p-3 rounded">
                                        <div className="text-xs text-gray-400 font-bold uppercase mb-2">Nombre del Archivo</div>
                                        <input 
                                            className="fluent-input w-full" 
                                            placeholder="Nombre del ZIP..." 
                                            value={exportOptions.customName} 
                                            onChange={e => setExportOptions({...exportOptions, customName: e.target.value})}
                                        />
                                    </div>
                                    <div className="bg-[#333] p-3 rounded"><div className="text-xs text-gray-400 font-bold uppercase mb-2">Formato de Imagen</div><div className="flex gap-2">{['original', 'png', 'jpeg'].map(fmt => (<button key={fmt} onClick={() => setExportOptions({...exportOptions, format: fmt})} className={`flex-1 py-1.5 rounded text-xs capitalize border ${exportOptions.format === fmt ? 'bg-[#0067c0] border-[#0067c0] text-white' : 'bg-[#2a2a2a] border-[#444] text-gray-400 hover:border-gray-500'}`}>{fmt}</button>))}</div></div>
                                    <label className="flex items-center gap-3 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.buckets} onChange={e=>setExportOptions({...exportOptions, buckets: e.target.checked})} className="w-5 h-5"/><div><div className="font-bold text-white">Organizar por Buckets</div><div className="text-xs text-gray-400">Crea carpetas por resoluci√≥n</div></div></label>
                                    <label className="flex items-center gap-3 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.stats} onChange={e=>setExportOptions({...exportOptions, stats: e.target.checked})} className="w-5 h-5"/><div><div className="font-bold text-white">Incluir Reporte JSON</div><div className="text-xs text-gray-400">Archivo con estad√≠sticas</div></div></label>
                                    <div className="flex gap-2"><label className="flex-1 flex items-center gap-2 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.images} onChange={e=>setExportOptions({...exportOptions, images: e.target.checked})} className="w-4 h-4"/> <span className="text-white">Im√°genes</span></label><label className="flex-1 flex items-center gap-2 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.text} onChange={e=>setExportOptions({...exportOptions, text: e.target.checked})} className="w-4 h-4"/> <span className="text-white">Textos</span></label></div>
                                    
                                    {isExporting && (
                                        <div className="mt-4">
                                            <div className="flex justify-between text-xs text-gray-400 mb-1">
                                                <span>Exportando...</span>
                                                <span>{exportProgress}%</span>
                                            </div>
                                            <div className="w-full h-2 bg-[#222] rounded-full overflow-hidden">
                                                <div className="h-full bg-[#0067c0] transition-all duration-300" style={{width: `${exportProgress}%`}}></div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                <div className="flex gap-2 justify-end">
                                    <button onClick={() => setExportModalOpen(false)} className="fluent-btn" disabled={isExporting}>Cancelar</button>
                                    <button onClick={executeExport} className="fluent-btn fluent-btn-primary px-6" disabled={isExporting}>{isExporting ? 'Procesando...' : 'Descargar ZIP'}</button>
                                </div>
                            </div>
                        </div>
                    )}
                    {bucketModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-3xl flex flex-col max-h-[80vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="monitor" /> Resoluciones</h2><button onClick={() => setBucketModalOpen(false)} className="fluent-btn">Cerrar</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2">{Object.entries(buckets).sort((a,b)=>b[1]-a[1]).map(([res, c]) => (<div key={res} className="flex items-center gap-4 text-sm"><div className="w-24 font-mono text-gray-300 text-right">{res}</div><div className="flex-1 bg-[#333] h-6 rounded overflow-hidden relative"><div className="bg-[#0067c0] h-full" style={{width: `${(c/files.length)*100}%`}}></div><span className="absolute inset-0 flex items-center pl-2 text-xs text-white">{c} img ({((c/files.length)*100).toFixed(1)}%)</span></div></div>))}</div>
                            </div>
                        </div>
                    )}
                    {consolidationModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-4xl flex flex-col max-h-[85vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><div><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="puzzle" /> Consolidaci√≥n</h2></div><div className="flex gap-2"><button onClick={applyConsolidation} className="fluent-btn fluent-btn-primary">Guardar</button><button onClick={() => setConsolidationModalOpen(false)} className="fluent-btn">Cancelar</button></div></div>
                                <div className="flex-1 overflow-y-auto p-4"><div className="grid grid-cols-2 md:grid-cols-3 gap-3">{tagStats.map(({ tag, count }) => (<div key={tag} className="bg-[#333] p-2 rounded flex flex-col gap-1 border border-[#444]"><div className="flex justify-between text-xs text-gray-400 mb-1"><span>Original: {tag}</span><span className="bg-[#222] px-1.5 rounded">{count}</span></div><input className="fluent-input text-xs" defaultValue={tag} onChange={(e) => handleTagEditChange(tag, e.target.value)}/></div>))}</div></div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
    </script>
</body>
</html>
