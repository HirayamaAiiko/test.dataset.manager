<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dataset Studio | Aiiko Labs</title>
    
    <!-- Favicon (Toolbox) -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='10' y='18' width='44' height='38' rx='4' fill='%230067c0'/%3E%3Cpath d='M10 24 L32 34 L54 24' stroke='white' stroke-width='3' fill='none'/%3E%3Cpath d='M32 34 V56' stroke='white' stroke-width='3'/%3E%3Cpath d='M42 6 L56 20 L42 34' stroke='%23fbbf24' stroke-width='4' stroke-linecap='round' fill='none' transform='rotate(-45 49 20)'/%3E%3C/svg%3E" type="image/svg+xml">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect x='10' y='18' width='44' height='38' rx='4' fill='%230067c0'/%3E%3Cpath d='M10 24 L32 34 L54 24' stroke='white' stroke-width='3' fill='none'/%3E%3Cpath d='M32 34 V56' stroke='white' stroke-width='3'/%3E%3Cpath d='M42 6 L56 20 L42 34' stroke='%23fbbf24' stroke-width='4' stroke-linecap='round' fill='none' transform='rotate(-45 49 20)'/%3E%3C/svg%3E">

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- JSZip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Cropper.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>

    <style>
        /* SCROLL FIX: Structure fixed at 100% viewport */
        html, body { 
            height: 100%; 
            width: 100%; 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #1a1a1a; 
            color: #e0e0e0; 
            font-family: 'Segoe UI', sans-serif; 
        }
        #root { height: 100%; width: 100%; position: absolute; top: 0; left: 0; overflow: hidden; }

        /* Fluent Style Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #2c2c2c; }
        ::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #666; }
        
        .fluent-input {
            background-color: #1e1e1e;
            border: 1px solid #3e3e3e;
            border-radius: 4px;
            padding: 6px;
            color: white;
            transition: all 0.2s;
            width: 100%;
        }
        .fluent-input:focus { border-color: #0067c0; outline: none; background-color: #1a1a1a; }
        
        .fluent-btn {
            background-color: #3c3c3c;
            border: 1px solid #454545;
            padding: 6px 12px;
            border-radius: 4px;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        .fluent-btn:hover:not(:disabled) { background-color: #484848; }
        .fluent-btn:active:not(:disabled) { background-color: #323232; transform: translateY(1px); }
        .fluent-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .fluent-btn-primary { background-color: #0067c0; border-color: #0067c0; }
        .fluent-btn-primary:hover:not(:disabled) { background-color: #1975c5; border-color: #1975c5; }

        .fluent-btn-success { background-color: #1a3f1a; border-color: #2e5c2e; color: #88ff88; }
        .fluent-btn-success:hover:not(:disabled) { background-color: #2e5c2e; }

        .fluent-btn-danger { background-color: #3f1a1a; border-color: #5c1e1e; color: #ff8888; }
        .fluent-btn-danger:hover:not(:disabled) { background-color: #5c1e1e; }

        .fluent-btn-sm { padding: 2px 8px; font-size: 0.75rem; height: 24px; }
        
        .item-card { transition: background-color 0.15s, border-color 0.15s; border: 1px solid transparent; }
        .item-card.selected { background-color: #2a3a4a; border-color: #0067c0; }
        .item-card:hover:not(.selected) { background-color: #2d2d2d; }

        /* Checkbox Custom Style */
        input[type="checkbox"] {
            accent-color: #0067c0;
            cursor: pointer;
        }

        .resizer-v { width: 5px; background: #252525; cursor: col-resize; z-index: 10; flex-shrink: 0; }
        .resizer-v:hover, .resizer-v.dragging { background: #0067c0; }

        .resizer-h { 
            height: 8px; 
            background: #252525; 
            cursor: row-resize; 
            z-index: 10; 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-shrink: 0; 
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
        }
        .resizer-h:hover, .resizer-h.dragging { background: #0067c0; }
        .resizer-h .grip { 
            width: 40px; 
            height: 4px; 
            background: #666; 
            border-radius: 2px; 
        }

        .checkerboard {
            background-image: linear-gradient(45deg, #252525 25%, transparent 25%), 
                              linear-gradient(-45deg, #252525 25%, transparent 25%), 
                              linear-gradient(45deg, transparent 75%, #252525 75%), 
                              linear-gradient(-45deg, transparent 75%, #252525 75%);
            background-size: 20px 20px;
        }
        
        .cropper-view-box, .cropper-face { border-radius: 0; outline: 1px solid #0067c0; }
        .cropper-line { background-color: #0067c0; }
        .cropper-point { width: 12px; height: 12px; background-color: #0067c0; opacity: 0.9; border-radius: 50%; }
        
        .tag-draggable { cursor: grab; transition: transform 0.2s, box-shadow 0.2s; }
        .tag-draggable:active { cursor: grabbing; box-shadow: 0 5px 10px rgba(0,0,0,0.3); transform: scale(1.05); z-index: 50; }

        .modal-overlay { background-color: rgba(0,0,0,0.8); backdrop-filter: blur(4px); z-index: 50; }
        
        .brand-title { cursor: pointer; transition: opacity 0.2s; }
        .brand-title:hover { opacity: 0.8; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef, Component, useCallback } = React;

        // --- INDEXEDDB SERVICE ---
        const DB_NAME = 'LoRaDatasetManagerDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'session';

        const dbService = {
            open: () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        }
                    };
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            saveSession: async (files) => {
                const db = await dbService.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    store.clear();
                    files.forEach(file => {
                        store.put({
                            id: file.id,
                            file: file.file,
                            originalName: file.originalName,
                            newName: file.newName,
                            extension: file.extension,
                            tags: file.tags,
                            tagCount: file.tagCount,
                            hash: file.hash,
                            width: file.width,
                            height: file.height
                        });
                    });
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            },
            loadSession: async () => {
                const db = await dbService.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            clearSession: async () => {
                const db = await dbService.open();
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    store.clear();
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            }
        };

        class ErrorBoundary extends Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError() { return { hasError: true }; }
            componentDidCatch(error, info) { console.error("Crash:", error, info); }
            render() {
                if (this.state.hasError) return <div className="h-full flex items-center justify-center text-red-400">⚠️ Critical Error. <button onClick={()=>location.reload()} className="ml-2 underline">Reload</button></div>;
                return this.props.children;
            }
        }

        const Icon = ({ name, size = 16, className }) => {
            const containerRef = useRef(null);
            useEffect(() => {
                if (containerRef.current && window.lucide) {
                    containerRef.current.innerHTML = '';
                    const i = document.createElement('i');
                    i.setAttribute('data-lucide', name);
                    containerRef.current.appendChild(i);
                    window.lucide.createIcons({ root: containerRef.current, attrs: { class: className, width: size, height: size } });
                }
            }, [name, size, className]);
            return <span ref={containerRef} className="inline-flex shrink-0 items-center justify-center"></span>;
        };

        const computeImageHash = async (blobUrl) => {
            return new Promise((resolve) => {
                const img = new Image(); img.src = blobUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas'); canvas.width = 8; canvas.height = 8;
                    const ctx = canvas.getContext('2d'); ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'medium';
                    ctx.drawImage(img, 0, 0, 8, 8);
                    const data = ctx.getImageData(0, 0, 8, 8).data;
                    let total = 0; for(let i=0; i<data.length; i+=4) total += (data[i] + data[i+1] + data[i+2]) / 3;
                    const avg = total / 64;
                    let hash = ""; for(let i=0; i<data.length; i+=4) hash += ((data[i] + data[i+1] + data[i+2]) / 3) > avg ? "1" : "0";
                    resolve({ hash, width: img.naturalWidth, height: img.naturalHeight });
                };
                img.onerror = () => resolve(null);
            });
        };

        const getHammingDistance = (hash1, hash2) => {
            let dist = 0; for(let i=0; i<hash1.length; i++) if(hash1[i] !== hash2[i]) dist++;
            return dist;
        };

        const levenshteinDistance = (a, b) => {
            const matrix = []; for(let i=0; i<=b.length; i++) matrix[i] = [i]; for(let j=0; j<=a.length; j++) matrix[0][j] = j;
            for(let i=1; i<=b.length; i++) for(let j=1; j<=a.length; j++) matrix[i][j] = b.charAt(i-1)==a.charAt(j-1) ? matrix[i-1][j-1] : Math.min(matrix[i-1][j-1]+1, Math.min(matrix[i][j-1]+1, matrix[i-1][j]+1));
            return matrix[b.length][a.length];
        };

        const convertImage = (fileUrl, format) => {
            return new Promise(resolve => {
                if (format === 'original') return resolve(null);
                const img = new Image(); img.src = fileUrl;
                img.onload = () => {
                    const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth; canvas.height = img.naturalHeight;
                    const ctx = canvas.getContext('2d');
                    if (format === 'jpeg') { ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0, 0, canvas.width, canvas.height); }
                    ctx.drawImage(img, 0, 0);
                    canvas.toBlob(blob => resolve({ blob, ext: '.' + (format === 'jpeg' ? 'jpg' : format) }), format === 'png' ? 'image/png' : 'image/jpeg', 0.95);
                };
                img.onerror = () => resolve(null);
            });
        };

        function App() {
            const [history, setHistory] = useState({ past: [], present: [], future: [] });
            const files = history.present;

            const setFiles = (newFilesOrUpdater) => {
                setHistory(curr => {
                    const newFiles = typeof newFilesOrUpdater === 'function' ? newFilesOrUpdater(curr.present) : newFilesOrUpdater;
                    const newPast = [...curr.past, curr.present].slice(-20);
                    return { past: newPast, present: newFiles, future: [] };
                });
            };
            
            // Auto-save
            useEffect(() => {
                const timer = setTimeout(() => {
                    if (files.length > 0) {
                        dbService.saveSession(files).catch(err => console.error("Auto-save failed", err));
                    }
                }, 1000);
                return () => clearTimeout(timer);
            }, [files]);

            // Restore
            useEffect(() => {
                const checkSession = async () => {
                    try {
                        const savedFiles = await dbService.loadSession();
                        if (savedFiles && savedFiles.length > 0) {
                            if (confirm(`Found previous session with ${savedFiles.length} files. Restore?`)) {
                                const revitalizedFiles = savedFiles.map(f => ({ ...f, url: URL.createObjectURL(f.file) }));
                                setHistory({ past: [], present: revitalizedFiles, future: [] });
                            } else {
                                dbService.clearSession();
                            }
                        }
                    } catch (e) { console.error("Error checking session", e); }
                };
                checkSession();
            }, []);

            const undo = useCallback(() => {
                setHistory(curr => {
                    if (curr.past.length === 0) return curr;
                    const previous = curr.past[curr.past.length - 1];
                    const newPast = curr.past.slice(0, -1);
                    return { past: newPast, present: previous, future: [curr.present, ...curr.future] };
                });
            }, []);

            useEffect(() => {
                const handleKeyDown = (e) => { if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); } };
                window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown);
            }, [undo]);

            useEffect(() => {
                const handleBeforeUnload = (e) => { if (files.length > 0) { const m = "⚠️"; e.preventDefault(); e.returnValue = m; return m; } };
                window.addEventListener('beforeunload', handleBeforeUnload); return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [files.length]);

            const [isMobile, setIsMobile] = useState(window.innerWidth < 1024);
            const [showMobileTools, setShowMobileTools] = useState(false);

            useEffect(() => {
                const handleResize = () => setIsMobile(window.innerWidth < 1024);
                window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize);
            }, []);

            const [selectedIds, setSelectedIds] = useState(new Set());
            const [activeId, setActiveId] = useState(null);
            const [loading, setLoading] = useState(false);
            const [loadingMsg, setLoadingMsg] = useState("Loading...");
            const [visibleLimit, setVisibleLimit] = useState(40);
            
            const [sidebarWidth, setSidebarWidth] = useState(300);
            const [editorWidth, setEditorWidth] = useState(380);
            const [previewHeight, setPreviewHeight] = useState(350);
            const [viewMode, setViewMode] = useState('list');
            const [sortMode, setSortMode] = useState('name_asc');
            const [filterStatus, setFilterStatus] = useState('all');
            
            const [filterText, setFilterText] = useState("");
            const [prefix, setPrefix] = useState("");
            const [triggerWord, setTriggerWord] = useState("");
            const [tagToDelete, setTagToDelete] = useState("");
            const [findText, setFindText] = useState("");
            const [replaceText, setReplaceText] = useState("");
            const [newTagInput, setNewTagInput] = useState("");

            const [isCropping, setIsCropping] = useState(false);
            const cropImgRef = useRef(null);
            const [cropperInstance, setCropperInstance] = useState(null);

            const isDraggingLeft = useRef(false);
            const isDraggingRight = useRef(false);
            const isDraggingPreview = useRef(false);
            const lastMousePos = useRef({ x: 0, y: 0 }); 
            
            const dragItem = useRef();
            const dragOverItem = useRef();
            const gridContainerRef = useRef(null);

            // Modals
            const [dupModalOpen, setDupModalOpen] = useState(false);
            const [dupGroups, setDupGroups] = useState([]); 
            const [dupChecking, setDupChecking] = useState(false);
            const [dupProgress, setDupProgress] = useState(0);
            const [bucketModalOpen, setBucketModalOpen] = useState(false);
            const [buckets, setBuckets] = useState({});
            const [consolidationModalOpen, setConsolidationModalOpen] = useState(false);
            const [tagStats, setTagStats] = useState([]);
            const [editedTagStats, setEditedTagStats] = useState({});
            const [typoModalOpen, setTypoModalOpen] = useState(false);
            const [typoCandidates, setTypoCandidates] = useState([]);
            const [exportModalOpen, setExportModalOpen] = useState(false);
            const [exportOptions, setExportOptions] = useState({ buckets: false, images: true, text: true, stats: false, format: 'original', customName: '' });
            const [exportProgress, setExportProgress] = useState(0); 
            const [isExporting, setIsExporting] = useState(false); 
            const [aboutModalOpen, setAboutModalOpen] = useState(false);

            // NEW: Global Tag Manager Modal State
            const [tagManagerOpen, setTagManagerOpen] = useState(false);
            const [tagManagerData, setTagManagerData] = useState([]); // { id: 1, original: "tag", current: "tag", deleted: false, count: 5 }

            const allUniqueTags = useMemo(() => {
                const counter = {}; files.forEach(f => f.tags.split(',').forEach(t => { const trimmed = t.trim(); if (trimmed) counter[trimmed] = (counter[trimmed] || 0) + 1; }));
                return Object.entries(counter).sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0])).map(([tag, count]) => ({ tag, count })); 
            }, [files]);

            const processedFiles = useMemo(() => {
                let res = files.filter(f => {
                    const matchesText = f.newName.toLowerCase().includes(filterText.toLowerCase()) || f.tags.toLowerCase().includes(filterText.toLowerCase());
                    let matchesStatus = true;
                    if (filterStatus === 'tagged') matchesStatus = f.tagCount > 0;
                    if (filterStatus === 'untagged') matchesStatus = f.tagCount === 0;
                    return matchesText && matchesStatus;
                });
                if (sortMode === 'name_desc') res.sort((a,b)=>b.newName.localeCompare(a.newName));
                else if (sortMode === 'tags_count') res.sort((a,b)=>b.tagCount-a.tagCount);
                else res.sort((a,b)=>a.newName.localeCompare(b.newName));
                return res;
            }, [files, filterText, sortMode, filterStatus]);
            const visibleFiles = processedFiles.slice(0, visibleLimit);

            useEffect(() => {
                const handleNav = (e) => {
                    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                    const keys = ['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'];
                    if (!keys.includes(e.key)) return;
                    e.preventDefault(); if (processedFiles.length === 0) return;
                    
                    const currentIndex = processedFiles.findIndex(f => f.id === activeId);
                    let nextIndex = currentIndex;
                    if (viewMode === 'list') {
                        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') nextIndex = Math.min(currentIndex + 1, processedFiles.length - 1);
                        else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') nextIndex = Math.max(currentIndex - 1, 0);
                    } else {
                        let cols = 1;
                        if (gridContainerRef.current) { cols = Math.floor((gridContainerRef.current.clientWidth + 8) / 128); if (cols < 1) cols = 1; }
                        if (e.key === 'ArrowRight') nextIndex = currentIndex + 1;
                        else if (e.key === 'ArrowLeft') nextIndex = currentIndex - 1;
                        else if (e.key === 'ArrowDown') nextIndex = currentIndex + cols;
                        else if (e.key === 'ArrowUp') nextIndex = currentIndex - cols;
                        nextIndex = Math.max(0, Math.min(nextIndex, processedFiles.length - 1));
                    }
                    if (nextIndex !== currentIndex && nextIndex !== -1) {
                        const nextId = processedFiles[nextIndex].id; setActiveId(nextId); setSelectedIds(new Set([nextId]));
                        const el = document.getElementById(`file-${nextId}`); if(el) el.scrollIntoView({block: 'nearest'});
                    }
                };
                window.addEventListener('keydown', handleNav); return () => window.removeEventListener('keydown', handleNav);
            }, [activeId, processedFiles, viewMode]);

            const handleScroll = (e) => { if (e.target.scrollHeight - e.target.scrollTop - e.target.clientHeight < 300) setVisibleLimit(prev => Math.min(prev + 40, files.length)); };

            useEffect(() => {
                const handleMove = (clientX, clientY) => {
                    const dx = clientX - lastMousePos.current.x;
                    const dy = clientY - lastMousePos.current.y;
                    lastMousePos.current = { x: clientX, y: clientY };

                    if (isDraggingLeft.current) setSidebarWidth(w => Math.max(200, Math.min(600, w + dx))); 
                    if (isDraggingLeft.current) setSidebarWidth(Math.max(200, Math.min(600, clientX)));
                    if (isDraggingRight.current) setEditorWidth(Math.max(300, Math.min(800, window.innerWidth - clientX)));
                    if (isDraggingPreview.current) setPreviewHeight(p => Math.max(150, Math.min(800, p + dy)));
                };

                const onMouseMove = (e) => { if (isDraggingLeft.current || isDraggingRight.current || isDraggingPreview.current) { e.preventDefault(); handleMove(e.clientX, e.clientY); } };
                const onTouchMove = (e) => { if (isDraggingLeft.current || isDraggingRight.current || isDraggingPreview.current) { e.preventDefault(); const touch = e.touches[0]; handleMove(touch.clientX, touch.clientY); } };
                const onUp = () => { isDraggingLeft.current = isDraggingRight.current = isDraggingPreview.current = false; document.body.style.cursor = 'default'; };

                document.addEventListener('mousemove', onMouseMove); document.addEventListener('mouseup', onUp);
                document.addEventListener('touchmove', onTouchMove, { passive: false }); document.addEventListener('touchend', onUp);
                return () => {
                    document.removeEventListener('mousemove', onMouseMove); document.removeEventListener('mouseup', onUp);
                    document.removeEventListener('touchmove', onTouchMove); document.removeEventListener('touchend', onUp);
                };
            }, []);

            const startDrag = (e, type) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                lastMousePos.current = { x: clientX, y: clientY };
                if (type === 'left') isDraggingLeft.current = true;
                if (type === 'right') isDraggingRight.current = true;
                if (type === 'preview') isDraggingPreview.current = true;
                document.body.style.cursor = type === 'preview' ? 'row-resize' : 'col-resize';
            };

            const confirmSafeToLoad = () => {
                if (files.length > 0) {
                    return confirm("⚠️ WARNING: You are about to open a new dataset.\n\nYour current session (tags, renames, edits) will be LOST unless you have exported it.\n\nAre you sure you want to continue?");
                }
                return true;
            };

            const handleFolderSelect = async (e) => {
                if (!confirmSafeToLoad()) {
                    e.target.value = ""; // Reset input
                    return;
                }
                setLoading(true); setLoadingMsg("Loading..."); setHistory({ past: [], present: [], future: [] }); setSelectedIds(new Set()); setActiveId(null);
                dbService.clearSession();
                await new Promise(r => setTimeout(r, 100));
                const fileList = Array.from(e.target.files);
                const imageFiles = fileList.filter(f => f.name.match(/\.(jpg|jpeg|png|webp)$/i));
                const textFiles = fileList.filter(f => f.name.endsWith('.txt'));
                const txtMap = new Map(); textFiles.forEach(f => txtMap.set(f.name, f));
                const newFilesData = [];
                try {
                    for (let img of imageFiles) {
                        const baseName = img.name.substring(0, img.name.lastIndexOf('.'));
                        let content = ""; const txtFile = txtMap.get(baseName + ".txt"); if (txtFile) content = await txtFile.text();
                        newFilesData.push({ id: Math.random().toString(36).substr(2, 9), file: img, url: URL.createObjectURL(img), originalName: img.name, newName: baseName, extension: img.name.substring(img.name.lastIndexOf('.')), tags: content, tagCount: content.split(',').filter(t => t.trim()).length, hash: null, width: 0, height: 0 });
                    }
                    newFilesData.sort((a, b) => a.originalName.localeCompare(b.originalName));
                    setHistory({ past: [], present: newFilesData, future: [] }); setVisibleLimit(40); setLoading(false);
                } catch (error) { console.error(error); alert("Error: " + error.message); setLoading(false); }
            };

            const handleZipSelect = async (e) => {
                if (!confirmSafeToLoad()) {
                    e.target.value = ""; // Reset input
                    return;
                }
                const file = e.target.files[0]; if (!file) return;
                setLoading(true); setLoadingMsg("Unzipping..."); setHistory({ past: [], present: [], future: [] }); setSelectedIds(new Set()); setActiveId(null);
                dbService.clearSession();
                try {
                    const zip = await JSZip.loadAsync(file);
                    const newFilesData = []; const validExtensions = ['.png', '.jpg', '.jpeg', '.webp']; const imageEntries = []; const textMap = new Map();
                    zip.forEach((relativePath, zipEntry) => { if (!zipEntry.dir) { const lowerName = relativePath.toLowerCase(); const ext = '.' + lowerName.split('.').pop(); if (validExtensions.includes(ext)) { imageEntries.push({ path: relativePath, entry: zipEntry, ext }); } else if (ext === '.txt') { textMap.set(relativePath, zipEntry); } } });
                    for (let i = 0; i < imageEntries.length; i++) {
                        const { path, entry, ext } = imageEntries[i]; if (path.includes('__MACOSX') || path.startsWith('.')) continue;
                        const blob = await entry.async("blob"); const url = URL.createObjectURL(blob);
                        const fileName = path.split('/').pop(); const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
                        const txtPath = path.substring(0, path.lastIndexOf('.')) + ".txt"; let content = ""; const txtEntry = textMap.get(txtPath);
                        if (txtEntry) content = await txtEntry.async("string");
                        newFilesData.push({ id: Math.random().toString(36).substr(2, 9), file: new File([blob], fileName, { type: blob.type }), url: url, originalName: fileName, newName: baseName, extension: ext, tags: content, tagCount: content.split(',').filter(t => t.trim()).length, hash: null, width: 0, height: 0 });
                        if (i % 20 === 0) { setLoadingMsg(`Processing ${Math.round((i / imageEntries.length) * 100)}%`); await new Promise(r => setTimeout(r, 0)); }
                    }
                    newFilesData.sort((a, b) => a.originalName.localeCompare(b.originalName)); setHistory({ past: [], present: newFilesData, future: [] }); setVisibleLimit(40); setLoading(false);
                } catch (error) { console.error(error); alert("ZIP Error: " + error.message); setLoading(false); }
            };

            const analyzeBuckets = async () => {
                setDupChecking(true); setDupProgress(0); const bucketMap = {}; const currentFiles = [...files];
                for (let i = 0; i < currentFiles.length; i++) {
                    const file = currentFiles[i];
                    if (file.width === 0) { await new Promise(resolve => { const img = new Image(); img.src = file.url; img.onload = () => { file.width = img.naturalWidth; file.height = img.naturalHeight; resolve(); }; img.onerror = resolve; }); }
                    if (file.width > 0) { const key = `${file.width}x${file.height}`; bucketMap[key] = (bucketMap[key] || 0) + 1; }
                    setDupProgress(Math.round(((i + 1) / currentFiles.length) * 100)); if (i % 20 === 0) await new Promise(r => setTimeout(r, 0));
                }
                setBuckets(bucketMap); setDupChecking(false); setBucketModalOpen(true);
            };

            const findDuplicates = async () => {
                setDupChecking(true); setDupProgress(0); const hashMap = {}; const currentFiles = [...files]; const THRESHOLD = 5; 
                for (let i = 0; i < currentFiles.length; i++) {
                    const file = currentFiles[i];
                    if (!file.hash) { const result = await computeImageHash(file.url); if (result) { file.hash = result.hash; file.width = result.width; file.height = result.height; } }
                    setDupProgress(Math.round(((i + 1) / currentFiles.length) * 50)); if (i % 5 === 0) await new Promise(r => setTimeout(r, 0)); 
                }
                const groups = []; const visited = new Set();
                for (let i = 0; i < currentFiles.length; i++) {
                    const fileA = currentFiles[i]; if (visited.has(fileA.id)) continue; const group = [fileA];
                    for (let j = i + 1; j < currentFiles.length; j++) {
                        const fileB = currentFiles[j]; if (visited.has(fileB.id)) continue;
                        if (fileA.hash && fileB.hash) { const dist = getHammingDistance(fileA.hash, fileB.hash); if (dist <= THRESHOLD) { group.push(fileB); visited.add(fileB.id); } }
                    }
                    if (group.length > 1) { groups.push(group); visited.add(fileA.id); }
                    setDupProgress(50 + Math.round(((i + 1) / currentFiles.length) * 50)); if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
                }
                setDupChecking(false); if (groups.length > 0) { setDupGroups(groups); setDupModalOpen(true); } else alert("No duplicates found!");
            };

            const findTypos = () => {
                const tags = allUniqueTags; const candidates = [];
                for (let i = 0; i < tags.length; i++) {
                    for (let j = i + 1; j < tags.length; j++) {
                        const t1 = tags[i]; const t2 = tags[j];
                        if (Math.abs(t1.tag.length - t2.tag.length) > 2 || t1.tag.length < 4 || t2.tag.length < 4) continue; 
                        const dist = levenshteinDistance(t1.tag, t2.tag);
                        if (dist > 0 && dist <= 2) { const likelyCorrect = t1.count >= t2.count ? t1 : t2; const likelyWrong = t1.count < t2.count ? t1 : t2; candidates.push({ correct: likelyCorrect, wrong: likelyWrong }); }
                    }
                }
                if (candidates.length > 0) { setTypoCandidates(candidates); setTypoModalOpen(true); } else alert("No obvious typos found.");
            };

            const fixTypo = (candidate) => {
                setFiles(prev => prev.map(f => {
                    const tags = f.tags.split(',').map(t => t.trim());
                    if (tags.includes(candidate.wrong.tag)) { const newTags = tags.map(t => t === candidate.wrong.tag ? candidate.correct.tag : t); const uniqueTags = [...new Set(newTags)]; return { ...f, tags: uniqueTags.join(', '), tagCount: uniqueTags.length }; } return f;
                }));
                setTypoCandidates(prev => prev.filter(c => c.wrong.tag !== candidate.wrong.tag)); if (typoCandidates.length <= 1) setTypoModalOpen(false);
            };

            const resolveDuplicate = (fileToDelete) => {
                setFiles(prev => prev.filter(f => f.id !== fileToDelete.id));
                setDupGroups(prevGroups => { const newGroups = prevGroups.map(group => group.filter(f => f.id !== fileToDelete.id)).filter(group => group.length > 1); if (newGroups.length === 0) setDupModalOpen(false); return newGroups; });
            };

            const openConsolidation = () => { const stats = allUniqueTags; setTagStats(stats); setEditedTagStats({}); setConsolidationModalOpen(true); };
            const handleTagEditChange = (originalTag, newText) => setEditedTagStats(prev => ({ ...prev, [originalTag]: newText }));
            const applyConsolidation = () => {
                const changes = Object.entries(editedTagStats).filter(([oldT, newT]) => newT && newT !== oldT);
                if (changes.length === 0) { setConsolidationModalOpen(false); return; }
                const replaceMap = {}; changes.forEach(([oldT, newT]) => replaceMap[oldT] = newT);
                setFiles(prev => prev.map(f => {
                    const tags = f.tags.split(',').map(t => t.trim()).filter(t => t); let changed = false;
                    const newTags = tags.map(t => { if (replaceMap[t]) { changed = true; return replaceMap[t]; } return t; });
                    if (changed) { const uniqueTags = [...new Set(newTags)]; return { ...f, tags: uniqueTags.join(', '), tagCount: uniqueTags.length }; } return f;
                }));
                setConsolidationModalOpen(false); alert(`Consolidated ${changes.length} tags.`);
            };

            // --- TAG MANAGER LOGIC ---
            const openTagManager = () => {
                if (files.length === 0) return;
                // Prepare initial state based on current tags
                const data = allUniqueTags.map(t => ({
                    original: t.tag,
                    current: t.tag,
                    deleted: false,
                    count: t.count
                }));
                setTagManagerData(data);
                setTagManagerOpen(true);
            };

            const toggleTagDelete = (index) => {
                setTagManagerData(prev => prev.map((item, i) => 
                    i === index ? { ...item, deleted: !item.deleted } : item
                ));
            };

            const editTagManagerTag = (index) => {
                const item = tagManagerData[index];
                const newName = prompt("Rename tag globally:", item.current);
                if (newName !== null) {
                    const trimmed = newName.trim();
                    if (trimmed) {
                        setTagManagerData(prev => prev.map((t, i) => 
                            i === index ? { ...t, current: trimmed } : t
                        ));
                    }
                }
            };

            const applyTagManagerChanges = () => {
                const changes = tagManagerData.filter(t => t.deleted || t.original !== t.current);
                if (changes.length === 0) {
                    setTagManagerOpen(false);
                    return;
                }

                if (!confirm(`Apply changes to ${changes.length} tags across the dataset? This cannot be easily undone.`)) return;

                const deleteSet = new Set(tagManagerData.filter(t => t.deleted).map(t => t.original));
                const renameMap = {};
                tagManagerData.forEach(t => {
                    if (!t.deleted && t.original !== t.current) {
                        renameMap[t.original] = t.current;
                    }
                });

                setFiles(prevFiles => prevFiles.map(f => {
                    const fileTags = f.tags.split(',').map(t => t.trim()).filter(t => t);
                    let fileChanged = false;

                    const newTags = fileTags.reduce((acc, tag) => {
                        if (deleteSet.has(tag)) {
                            fileChanged = true;
                            return acc; // Skip (delete)
                        }
                        if (renameMap[tag]) {
                            fileChanged = true;
                            acc.push(renameMap[tag]);
                        } else {
                            acc.push(tag);
                        }
                        return acc;
                    }, []);

                    if (fileChanged) {
                        // Re-uniquify in case renames caused duplicates
                        const uniqueTags = [...new Set(newTags)];
                        return { ...f, tags: uniqueTags.join(', '), tagCount: uniqueTags.length };
                    }
                    return f;
                }));

                setTagManagerOpen(false);
                alert("Tag changes applied successfully!");
            };

            const openExport = () => {
                if (files.length === 0) return;
                let suggestedName = "Dataset";
                if (triggerWord) { suggestedName = triggerWord + " Dataset v1"; } 
                else if (allUniqueTags.length > 0) { suggestedName = allUniqueTags[0].tag + " Dataset v1"; }
                setExportOptions(prev => ({ ...prev, customName: suggestedName }));
                setExportModalOpen(true);
            };

            const executeExport = async () => {
                // SAFETY: Mobile protection
                if (isMobile) {
                    if (files.length > 25) {
                        alert("⚠️ Mobile Memory Warning\n\nExporting > 25 images as ZIP might crash your browser.\n\nStarting SEQUENTIAL download (one by one). Please allow multiple downloads.");
                        setIsExporting(true);
                        setExportProgress(0);
                        setExportModalOpen(false); 

                        for (let i = 0; i < files.length; i++) {
                            const f = files[i];
                            const n = f.newName;
                            const aImg = document.createElement('a'); aImg.href = f.url; aImg.download = `${n}${f.extension}`; document.body.appendChild(aImg); aImg.click(); document.body.removeChild(aImg);
                            await new Promise(r => setTimeout(r, 1500)); 
                            if (exportOptions.text) {
                                const blobTxt = new Blob([f.tags], {type: 'text/plain'});
                                const urlTxt = URL.createObjectURL(blobTxt);
                                const aTxt = document.createElement('a'); aTxt.href = urlTxt; aTxt.download = `${n}.txt`; document.body.appendChild(aTxt); aTxt.click(); document.body.removeChild(aTxt); URL.revokeObjectURL(urlTxt);
                            }
                            setExportProgress(Math.round(((i + 1) / files.length) * 100));
                            await new Promise(r => setTimeout(r, 500));
                        }
                        setIsExporting(false);
                        alert("Sequential download finished.");
                        return;
                    } else {
                        if (!confirm("⚠️ Memory Warning\n\nAre you sure you want to generate a ZIP on mobile? Low RAM might cause crashes.")) return;
                    }
                }

                setIsExporting(true);
                setExportProgress(0);
                
                try {
                    const zip = new JSZip();
                    const counts = {};
                    if (exportOptions.stats) { const statsData = { total_files: files.length, unique_tags: allUniqueTags.length, top_tags: allUniqueTags.slice(0, 50), generated_at: new Date().toISOString() }; zip.file("dataset_stats.json", JSON.stringify(statsData, null, 2)); }
                    if (exportOptions.buckets) { for (const f of files) { if (f.width === 0) { await new Promise(resolve => { const img = new Image(); img.src = f.url; img.onload = () => { f.width = img.naturalWidth; f.height = img.naturalHeight; resolve(); }; img.onerror = resolve; }); } } }
                    for (let i = 0; i < files.length; i++) {
                        const f = files[i]; let n = f.newName; if(counts[n]) n = `${n}_${++counts[n]}`; else counts[n]=1;
                        let folderPrefix = ""; if (exportOptions.buckets && f.width > 0) folderPrefix = `${f.width}x${f.height}/`;
                        if (exportOptions.images) {
                            if (exportOptions.format === 'original') zip.file(`${folderPrefix}${n}${f.extension}`, f.file);
                            else { const converted = await convertImage(f.url, exportOptions.format); if (converted) zip.file(`${folderPrefix}${n}${converted.ext}`, converted.blob); else zip.file(`${folderPrefix}${n}${f.extension}`, f.file); }
                        }
                        if (exportOptions.text) zip.file(`${folderPrefix}${n}.txt`, f.tags);
                        setExportProgress(Math.round(((i + 1) / files.length) * 100));
                        await new Promise(r => setTimeout(r, isMobile ? 50 : 0));
                    }
                    const compressionMethod = isMobile ? "STORE" : "DEFLATE";
                    const c = await zip.generateAsync({ type: "blob", compression: compressionMethod });
                    const a = document.createElement('a'); a.href = URL.createObjectURL(c); 
                    let finalName = exportOptions.customName.trim() || "dataset";
                    if (!finalName.toLowerCase().endsWith(".zip")) finalName += ".zip";
                    a.download = finalName; a.click();
                } catch (err) { alert("Export Error: " + err.message); } 
                finally { setIsExporting(false); setExportModalOpen(false); }
            };

            useEffect(() => {
                if (isCropping && cropImgRef.current) { const cropper = new Cropper(cropImgRef.current, { viewMode: 1, dragMode: 'move', autoCropArea: 1, background: false, zoomable: true, scalable: true }); setCropperInstance(cropper); return () => cropper.destroy(); }
            }, [isCropping, activeId]); 
            const setCropRatio = (r) => cropperInstance && cropperInstance.setAspectRatio(r);
            const saveCrop = () => {
                if (!cropperInstance || !activeFile) return;
                cropperInstance.getCroppedCanvas().toBlob((blob) => {
                    const newUrl = URL.createObjectURL(blob); const baseName = activeFile.newName + "_crop";
                    const newFile = { ...activeFile, id: Math.random().toString(36).substr(2, 9), file: blob, url: newUrl, originalName: baseName + ".png", newName: baseName, extension: ".png", hash: null };
                    setFiles(prev => [...prev, newFile]); setIsCropping(false);
                });
            };

            const activeFile = useMemo(() => files.find(f => f.id === activeId), [files, activeId]);
            const getTargets = () => selectedIds.size > 0 ? files.filter(f => selectedIds.has(f.id)) : files;
            const updateFiles = (updater) => setFiles(prev => prev.map(updater));
            const updateActiveTags = (newTags) => { if (!activeId) return; const count = newTags.split(',').filter(t => t.trim()).length; setFiles(prev => prev.map(f => f.id === activeId ? { ...f, tags: newTags, tagCount: count } : f)); };
            const handleTagSort = () => { if (!activeFile) return; const tagsArray = activeFile.tags.split(',').map(t => t.trim()).filter(t => t); const dragged = tagsArray[dragItem.current]; tagsArray.splice(dragItem.current, 1); tagsArray.splice(dragOverItem.current, 0, dragged); dragItem.current = null; dragOverItem.current = null; updateActiveTags(tagsArray.join(', ')); };
            const addTag = () => { if (!activeId || !newTagInput.trim()) return; const current = activeFile.tags.split(',').map(t => t.trim()).filter(t => t); if (!current.includes(newTagInput.trim())) updateActiveTags([...current, newTagInput.trim()].join(', ')); setNewTagInput(""); };
            const removeTag = (tag) => { const current = activeFile.tags.split(',').map(t => t.trim()); updateActiveTags(current.filter(t => t !== tag).join(', ')); };
            const batchRename = () => { if (!prefix) return; const ids = new Set(getTargets().map(f => f.id)); let c = 1; updateFiles(f => ids.has(f.id) ? { ...f, newName: `${prefix}_${String(c++).padStart(3, '0')}` } : f); };
            
            const addTrigger = () => {
                if (!triggerWord) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim()).filter(t => t);
                        if (!tags.includes(triggerWord)) {
                            const newTags = [triggerWord, ...tags];
                            return { ...f, tags: newTags.join(', '), tagCount: newTags.length };
                        }
                    }
                    return f;
                });
            };

            const deleteTag = () => {
                if (!tagToDelete) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim()).filter(t => t.toLowerCase() !== tagToDelete.toLowerCase());
                        return { ...f, tags: tags.join(', '), tagCount: tags.length };
                    }
                    return f;
                });
            };
            
            const searchRep = () => {
                if (!findText) return;
                const ids = new Set(getTargets().map(f => f.id));
                updateFiles(f => {
                    if (ids.has(f.id)) {
                        const tags = f.tags.split(',').map(t => t.trim() === findText ? replaceText : t.trim()).filter(t => t);
                        return { ...f, tags: tags.join(', '), tagCount: tags.length };
                    }
                    return f;
                });
            };

            const deleteSelected = () => { const targets = getTargets(); if (!targets.length || !confirm(`Delete ${targets.length} images?`)) return; const ids = new Set(targets.map(f => f.id)); if (activeId && ids.has(activeId)) { setActiveId(null); setIsCropping(false); } setFiles(prev => prev.filter(f => !ids.has(f.id))); setSelectedIds(new Set()); };
            
            const clearAllTags = () => {
                const targets = getTargets();
                if (targets.length === 0) return;
                if (!confirm(`Clear ALL tags for ${targets.length} images? This is destructive.`)) return;
                const ids = new Set(targets.map(f => f.id));
                updateFiles(f => ids.has(f.id) ? { ...f, tags: '', tagCount: 0 } : f);
            };

            const dedupTags = () => { const ids = new Set(getTargets().map(f => f.id)); let changes = 0; const newF = files.map(f => { if (ids.has(f.id)) { const tags = f.tags.split(',').map(t=>t.trim()).filter(t=>t); const seen = new Set(); const unique = tags.filter(t => { const l = t.toLowerCase(); if(seen.has(l)) return false; seen.add(l); return true; }); if (unique.length !== tags.length) { changes++; return { ...f, tags: unique.join(', '), tagCount: unique.length }; } } return f; }); if (changes) { setFiles(newF); alert(`Fixed ${changes} files.`); } else alert("No duplicates."); };
            
            const handleSelect = (id, multi) => { const newS = new Set(multi ? selectedIds : []); if (newS.has(id)) newS.delete(id); else newS.add(id); setSelectedIds(newS); if (!multi || newS.size === 1) { setActiveId(id); setIsCropping(false); } };

            const LeftPanelContent = (
                <>
                    <div className="p-4 border-b border-[#3e3e3e] flex-shrink-0">
                        {isMobile && <div className="flex justify-between items-center mb-4"><h1 className="font-bold text-lg text-white flex items-center gap-2 brand-title" onClick={() => setAboutModalOpen(true)}>Dataset Studio <span className="text-xs font-normal text-gray-400">| Aiiko Labs</span></h1><button onClick={() => setShowMobileTools(false)} className="fluent-btn">Close</button></div>}
                        {!isMobile && <h1 className="font-bold text-lg text-white mb-2 flex items-center gap-2 brand-title" onClick={() => setAboutModalOpen(true)}>Dataset Studio <span className="text-xs font-normal text-gray-400">| Aiiko Labs</span></h1>}
                        <div className="flex gap-2">
                            <label className={`fluent-btn fluent-btn-primary flex-1 block text-center cursor-pointer ${loading ? 'opacity-50 pointer-events-none' : ''}`}>{loading ? "..." : "📂 Folder"}<input type="file" webkitdirectory="true" multiple className="hidden" onChange={handleFolderSelect} disabled={loading} /></label>
                            <label className={`fluent-btn flex-1 block text-center cursor-pointer ${loading ? 'opacity-50 pointer-events-none' : ''}`}>📦 ZIP<input type="file" accept=".zip" className="hidden" onChange={handleZipSelect} disabled={loading} /></label>
                        </div>
                        <div className="text-xs text-gray-400 mt-2 text-center flex justify-between"><span>Total: {files.length}</span>{history.past.length > 0 && <span className="text-gray-500 font-bold" title="Ctrl+Z to undo">↩ Undo</span>}</div>
                    </div>
                    <div className="flex-1 overflow-y-auto p-4 space-y-4 min-h-0">
                        <div className="flex gap-2"><button onClick={()=>{setSelectedIds(new Set(files.map(f=>f.id)))}} className="fluent-btn flex-1">All</button><button onClick={()=>{setSelectedIds(new Set())}} className="fluent-btn flex-1">None</button></div>
                        <div className="space-y-2 pt-2 border-t border-[#3e3e3e]">
                            <p className="text-xs font-bold text-gray-500 uppercase">Tag Editing</p>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Rename files..." value={prefix} onChange={e=>setPrefix(e.target.value)} /><button onClick={batchRename} className="fluent-btn"><Icon name="edit-3" size={14}/></button></div>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Trigger..." value={triggerWord} onChange={e=>setTriggerWord(e.target.value)} /><button onClick={addTrigger} className="fluent-btn"><Icon name="plus" size={14}/></button></div>
                            <div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Delete tag..." value={tagToDelete} onChange={e=>setTagToDelete(e.target.value)} /><button onClick={deleteTag} className="fluent-btn text-red-400"><Icon name="trash-2" size={14}/></button></div>
                            <div className="space-y-2"><input className="fluent-input" placeholder="Search..." value={findText} onChange={e=>setFindText(e.target.value)}/><div className="flex gap-2"><input className="fluent-input flex-1" placeholder="Replace..." value={replaceText} onChange={e=>setReplaceText(e.target.value)} /><button onClick={searchRep} className="fluent-btn">OK</button></div></div>
                            <button onClick={clearAllTags} className="fluent-btn w-full justify-start gap-2 text-red-400 hover:text-red-300 hover:bg-red-900/20 mt-1"><Icon name="eraser" size={14}/> Wipe All Tags</button>
                        </div>
                        <div className="space-y-2 pt-2 border-t border-[#3e3e3e]">
                            <p className="text-xs font-bold text-gray-500 uppercase">Tools</p>
                            <button onClick={openTagManager} className="fluent-btn w-full justify-start gap-2 text-purple-300 hover:text-purple-100"><Icon name="tags" size={14}/> 🏷️ Global Tag Manager</button>
                            <button onClick={findTypos} className="fluent-btn w-full justify-start gap-2 text-yellow-300 hover:text-yellow-100"><Icon name="search" size={14}/> 🔍 Detect Typos</button>
                            <button onClick={dedupTags} className="fluent-btn w-full justify-start gap-2"><Icon name="scissors" size={14}/> Dedup Tags</button>
                            <button onClick={deleteSelected} className="fluent-btn fluent-btn-danger w-full justify-start gap-2"><Icon name="trash" size={14}/> Delete (Img+Txt)</button>
                            <button onClick={openConsolidation} className="fluent-btn w-full justify-start gap-2 text-blue-300 hover:text-blue-100"><Icon name="puzzle" size={14}/> 🧩 Old Consolidator</button>
                            <button onClick={analyzeBuckets} className="fluent-btn w-full justify-start gap-2 text-blue-200 hover:text-blue-100"><Icon name="monitor" size={14}/> 📊 Buckets</button>
                            <div className="flex flex-col gap-1">
                                <button onClick={findDuplicates} disabled={dupChecking} className="fluent-btn w-full justify-start gap-2 bg-[#4a3a1a] border-[#665522] text-[#ffdd88] hover:bg-[#665522]">
                                    <Icon name="copy" size={14}/> Detect Duplicate Images
                                </button>
                                {dupChecking && (
                                    <div className="w-full h-1.5 bg-[#222] rounded-full overflow-hidden">
                                        <div className="h-full bg-[#ffdd88] transition-all duration-300" style={{width: `${dupProgress}%`}}></div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                    <div className="p-4 border-t border-[#3e3e3e] flex-shrink-0"><button onClick={openExport} className="fluent-btn fluent-btn-primary w-full py-3 font-bold flex justify-center gap-2" disabled={!files.length}><Icon name="download"/> Export ZIP</button></div>
                </>
            );

            const CenterPanelContent = (
                <>
                    <div className="p-2 border-b border-[#3e3e3e] flex-shrink-0">
                        {isMobile ? (
                            // Mobile Layout: Column
                            <div className="flex flex-col gap-2">
                                <div className="flex items-center gap-2">
                                    <button onClick={() => setShowMobileTools(true)} className="fluent-btn flex-shrink-0"><Icon name="menu"/></button>
                                    <div className="flex-1 flex items-center bg-[#1e1e1e] border border-[#3e3e3e] rounded px-2">
                                        <Icon name="search" className="text-gray-400 flex-shrink-0"/>
                                        <input className="fluent-input bg-transparent border-none flex-1 p-2" placeholder="Filter..." list="tag-suggestions" value={filterText} onChange={e=>setFilterText(e.target.value)}/>
                                    </div>
                                </div>
                                <div className="flex items-center gap-2 overflow-x-auto no-scrollbar">
                                    <select className="bg-[#333] text-white text-xs p-2 rounded border-none outline-none flex-shrink-0" value={filterStatus} onChange={e=>setFilterStatus(e.target.value)}>
                                        <option value="all">All</option>
                                        <option value="tagged">Tagged</option>
                                        <option value="untagged">Untagged</option>
                                    </select>
                                    <select className="bg-[#333] text-white text-xs p-2 rounded border-none outline-none flex-shrink-0" value={sortMode} onChange={e=>setSortMode(e.target.value)}>
                                        <option value="name_asc">A-Z</option>
                                        <option value="name_desc">Z-A</option>
                                        <option value="tags_count"># Tags</option>
                                    </select>
                                    <div className="flex bg-[#333] rounded p-0.5 flex-shrink-0 ml-auto">
                                        <button className={`p-1.5 rounded ${viewMode==='list'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('list')}><Icon name="list" size={16}/></button>
                                        <button className={`p-1.5 rounded ${viewMode==='grid'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('grid')}><Icon name="grid" size={16}/></button>
                                        <button className="p-1.5 rounded text-red-400 hover:bg-red-900/30 hover:text-red-200 ml-1 border-l border-[#444]" onClick={deleteSelected} title="Delete Selected" disabled={selectedIds.size === 0}><Icon name="trash" size={16}/></button>
                                    </div>
                                </div>
                            </div>
                        ) : (
                            // Desktop Layout: Row (Original)
                            <div className="flex items-center gap-2">
                                <Icon name="search" className="text-gray-400"/>
                                <input className="fluent-input bg-transparent border-none flex-1" placeholder="Filter..." list="tag-suggestions" value={filterText} onChange={e=>setFilterText(e.target.value)}/>
                                <select className="bg-[#333] text-white text-xs p-1 rounded border-none outline-none" value={filterStatus} onChange={e=>setFilterStatus(e.target.value)}>
                                    <option value="all">All</option>
                                    <option value="tagged">Tagged</option>
                                    <option value="untagged">Untagged</option>
                                </select>
                                <select className="bg-[#333] text-white text-xs p-1 rounded border-none outline-none" value={sortMode} onChange={e=>setSortMode(e.target.value)}>
                                    <option value="name_asc">A-Z</option>
                                    <option value="name_desc">Z-A</option>
                                    <option value="tags_count"># Tags</option>
                                </select>
                                <div className="flex bg-[#333] rounded p-0.5">
                                    <button className={`p-1.5 rounded ${viewMode==='list'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('list')}><Icon name="list" size={16}/></button>
                                    <button className={`p-1.5 rounded ${viewMode==='grid'?'bg-[#444] text-white':'text-gray-400'}`} onClick={()=>setViewMode('grid')}><Icon name="grid" size={16}/></button>
                                    <button className="p-1.5 rounded text-red-400 hover:bg-red-900/30 hover:text-red-200 ml-1 border-l border-[#444]" onClick={deleteSelected} title="Delete Selected" disabled={selectedIds.size === 0}><Icon name="trash" size={16}/></button>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="flex-1 overflow-y-auto p-2 min-h-0" onScroll={handleScroll}>
                        {!files.length && !loading && <div className="h-full flex flex-col items-center justify-center text-gray-500"><Icon name="folder-open" size={48} className="mb-4 opacity-50"/><p>Upload a Folder or ZIP</p></div>}
                        {loading && <div className="h-full flex flex-col items-center justify-center text-blue-400 animate-pulse"><p className="font-bold">{loadingMsg}</p></div>}
                        <div ref={gridContainerRef} className={viewMode==='grid'?"grid grid-cols-[repeat(auto-fill,minmax(120px,1fr))] gap-2":"flex flex-col gap-1"}>
                            {visibleFiles.map(f => (
                                <div key={f.id} id={`file-${f.id}`} onClick={(e)=>handleSelect(f.id, e.ctrlKey||e.metaKey)} className={`item-card rounded cursor-pointer relative overflow-hidden group ${viewMode==='grid'?'aspect-[3/4] flex flex-col bg-[#252525]':'flex items-center gap-3 p-2 border-b border-[#2a2a2a]'} ${selectedIds.has(f.id)?'selected':''}`}>
                                    <div className={viewMode==='grid' ? "absolute top-2 left-2 z-20" : ""} onClick={(e)=>e.stopPropagation()}>
                                        <input type="checkbox" checked={selectedIds.has(f.id)} onChange={()=>handleSelect(f.id, true)} className="w-5 h-5 accent-[#0067c0] cursor-pointer drop-shadow-md border border-white/20 rounded-sm"/>
                                    </div>
                                    <div className={`${viewMode==='grid'?'flex-1 w-full':'w-12 h-12'} bg-black overflow-hidden relative`}>
                                        <img src={f.url} className="w-full h-full object-contain" draggable="false" loading="lazy" />
                                        {selectedIds.has(f.id) && <div className="absolute top-1 right-1 bg-[#0067c0] text-white rounded-full p-0.5"><Icon name="check" size={12}/></div>}
                                    </div>
                                    <div className={`${viewMode==='grid'?'p-2 text-center text-xs h-12':'flex-1 min-w-0'}`}>
                                        <div className="font-bold text-white truncate" title={f.newName}>{f.newName}</div>
                                        <div className="text-xs text-gray-500 truncate">{f.tagCount} tags</div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </>
            );

            const RightPanelContent = activeFile ? (
                <>
                    <div className="p-4 border-b border-[#3e3e3e] bg-[#252525] flex-shrink-0">
                        {isMobile && <div className="flex items-center mb-4"><button onClick={() => setActiveId(null)} className="fluent-btn w-full">⬅ Back to Gallery</button></div>}
                        <div className="flex justify-between items-center mb-2">
                            <h2 className="font-bold text-xs uppercase text-gray-500">Preview</h2>
                            {isCropping ? <div className="flex gap-1"><button onClick={()=>setCropRatio(NaN)} className="fluent-btn fluent-btn-sm">Free</button><button onClick={()=>setCropRatio(1)} className="fluent-btn fluent-btn-sm">1:1</button><button onClick={()=>setCropRatio(2/3)} className="fluent-btn fluent-btn-sm">2:3</button><button onClick={()=>setCropRatio(3/2)} className="fluent-btn fluent-btn-sm">3:2</button><button onClick={saveCrop} className="fluent-btn fluent-btn-sm bg-[#0067c0]">Save</button><button onClick={()=>setIsCropping(false)} className="text-xs text-gray-400 hover:text-white px-2">X</button></div> : <button onClick={()=>setIsCropping(true)} className="text-xs flex gap-1 items-center hover:text-white text-gray-400"><Icon name="crop" size={12}/> Crop</button>}
                        </div>
                        
                        {/* RESIZABLE PREVIEW */}
                        <div style={{height: previewHeight}} className="w-full bg-[#1a1a1a] border border-[#3e3e3e] flex items-center justify-center overflow-hidden relative checkerboard">
                            {isCropping ? <img ref={cropImgRef} src={activeFile.url} className="max-w-full block" /> : <img src={activeFile.url} className="w-full h-full object-contain" />}
                        </div>
                        <div className="resizer-h mt-1 mb-2" onMouseDown={(e) => startDrag(e, 'preview')} onTouchStart={(e) => startDrag(e, 'preview')}><div className="grip"></div></div>
                        
                        <div className="text-xs text-gray-400 text-center select-text">{activeFile.originalName}</div>
                    </div>
                    <div className="flex-1 p-4 overflow-y-auto flex flex-col gap-4 min-h-0">
                        <div><label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Filename</label><input className="fluent-input" value={activeFile.newName} onChange={e=>updateFiles(f=>f.id===activeId?{...f,newName:e.target.value}:f)} /></div>
                        <div>
                            <label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Tags (Draggable)</label>
                            <div className="flex gap-2 mb-2"><input className="fluent-input flex-1" placeholder="Add tag..." list="tag-suggestions" value={newTagInput} onChange={e=>setNewTagInput(e.target.value)} onKeyDown={e=>e.key==='Enter'&&addTag()}/><button onClick={addTag} className="fluent-btn text-lg leading-none">+</button></div>
                            <div className="flex flex-wrap gap-1 bg-[#1a1a1a] p-2 rounded min-h-[60px] content-start">
                                {activeFile.tags.split(',').map(t=>t.trim()).filter(t=>t).map((tag, i)=>(<span key={i} className="bg-[#3a3a3a] border border-[#555] text-white text-xs px-2 py-1 rounded flex items-center gap-1 group hover:border-[#0067c0] tag-draggable" draggable onDragStart={()=>dragItem.current=i} onDragEnter={()=>dragOverItem.current=i} onDragEnd={handleTagSort} onDragOver={e=>e.preventDefault()}>{tag}<button onClick={()=>removeTag(tag)} className="hover:text-red-300 opacity-50 group-hover:opacity-100 ml-1">×</button></span>))}
                            </div>
                        </div>
                        <div><label className="text-xs font-bold text-gray-400 uppercase mb-1 block">Raw Text</label><textarea className="fluent-input h-32 font-mono text-xs" value={activeFile.tags} onChange={e=>updateActiveTags(e.target.value)}></textarea></div>
                    </div>
                </>
            ) : <div className="flex-1 flex flex-col items-center justify-center text-gray-500 p-8 text-center"><Icon name="mouse-pointer-2" size={32} className="mb-2 opacity-50"/><p>Select an image</p></div>;

            return (
                <div className="flex h-full w-full overflow-hidden text-sm select-none">
                    <datalist id="tag-suggestions">{allUniqueTags.map(({tag, count}) => <option key={tag} value={tag} label={`${tag} (${count})`} />)}</datalist>
                    {isMobile ? (
                        <div className="flex flex-col w-full h-full bg-[#1a1a1a]">
                            {activeFile ? <div className="flex-1 flex flex-col h-full overflow-hidden">{RightPanelContent}</div> : showMobileTools ? <div className="flex-1 flex flex-col bg-[#2c2c2c] h-full overflow-hidden">{LeftPanelContent}</div> : <div className="flex-1 flex flex-col h-full overflow-hidden">{CenterPanelContent}</div>}
                        </div>
                    ) : (
                        <>
                            <div className="bg-[#2c2c2c] flex flex-col border-r border-[#3e3e3e] h-full overflow-hidden" style={{ width: sidebarWidth }}>{LeftPanelContent}</div>
                            <div className="resizer-v" onMouseDown={(e) => startDrag(e, 'left')} onTouchStart={(e) => startDrag(e, 'left')}></div>
                            <div className="flex-1 bg-[#202020] flex flex-col min-w-0 h-full overflow-hidden">{CenterPanelContent}</div>
                            <div className="resizer-v" onMouseDown={(e) => startDrag(e, 'right')} onTouchStart={(e) => startDrag(e, 'right')}></div>
                            <div className="bg-[#2c2c2c] border-l border-[#3e3e3e] flex flex-col h-full overflow-hidden" style={{ width: editorWidth }}>{RightPanelContent}</div>
                        </>
                    )}
                    
                    {/* --- GLOBAL TAG MANAGER MODAL --- */}
                    {tagManagerOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-6xl flex flex-col h-[85vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg">
                                    <div>
                                        <h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="tags" /> Global Tag Manager</h2>
                                        <p className="text-xs text-gray-400">Double click chip to rename. Click X to delete. Click Apply to save.</p>
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={applyTagManagerChanges} className="fluent-btn fluent-btn-success font-bold"><Icon name="save" size={16}/> Apply Changes</button>
                                        <button onClick={() => setTagManagerOpen(false)} className="fluent-btn">Cancel</button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto p-4">
                                    <div className="flex flex-wrap gap-2 content-start">
                                        {tagManagerData.map((item, index) => {
                                            if (item.deleted) {
                                                 return (
                                                    <span key={index} className="bg-[#3f1a1a] border border-[#5c1e1e] text-red-400 text-xs px-3 py-1.5 rounded-full flex items-center gap-2 opacity-60">
                                                        <span className="line-through">{item.original}</span>
                                                        <button onClick={() => toggleTagDelete(index)} className="hover:text-white" title="Restore">↩</button>
                                                    </span>
                                                 );
                                            }
                                            const isModified = item.original !== item.current;
                                            return (
                                                <span 
                                                    key={index} 
                                                    className={`${isModified ? 'bg-[#1a2e3f] border-[#0067c0] text-blue-200' : 'bg-[#333] border-[#555] text-white'} border text-xs px-3 py-1.5 rounded-full flex items-center gap-2 group hover:border-gray-400 transition-colors select-none`}
                                                    onDoubleClick={() => editTagManagerTag(index)}
                                                    title="Double click to rename"
                                                >
                                                    <span>{item.current}</span>
                                                    <span className="bg-black/30 px-1.5 rounded text-[10px] text-gray-400">{item.count}</span>
                                                    <button onClick={(e) => { e.stopPropagation(); toggleTagDelete(index); }} className="hover:text-red-400 ml-1 text-gray-500 font-bold">×</button>
                                                </span>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* DUP MODAL */}
                    {dupModalOpen && dupGroups.length > 0 && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-5xl h-[80vh] flex flex-col">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="copy" /> Conflicts: {dupGroups.length} groups</h2><button onClick={() => setDupModalOpen(false)} className="fluent-btn">Close</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-6">{dupGroups.map((group, gIdx) => (<div key={gIdx} className="bg-[#1a1a1a] p-4 rounded border border-[#333]"><div className="flex gap-4 overflow-x-auto pb-2">{group.map(file => (<div key={file.id} className="flex-1 min-w-[200px] bg-[#252525] p-3 rounded border border-[#333] flex flex-col gap-2"><div className="h-40 bg-black flex items-center justify-center rounded overflow-hidden"><img src={file.url} className="max-w-full max-h-full object-contain" /></div><div className="text-xs space-y-1"><div className="font-bold text-white truncate">{file.originalName}</div><div className="text-gray-400">{file.width}x{file.height}</div></div><button onClick={() => resolveDuplicate(file)} className="fluent-btn fluent-btn-danger w-full mt-auto"><Icon name="trash" size={14}/> Delete</button></div>))}</div></div>))}</div>
                            </div>
                        </div>
                    )}
                    {/* TYPO MODAL */}
                    {typoModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-3xl flex flex-col max-h-[80vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="search" /> Potential Typos ({typoCandidates.length})</h2><button onClick={() => setTypoModalOpen(false)} className="fluent-btn">Close</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-3">{typoCandidates.map((c, i) => (<div key={i} className="flex items-center justify-between bg-[#333] p-3 rounded border border-[#444]"><div className="flex items-center gap-4"><div className="text-right"><div className="text-red-400 font-bold strike">{c.wrong.tag}</div><div className="text-xs text-gray-500">({c.wrong.count} uses)</div></div><Icon name="arrow-right" className="text-gray-500" /><div><div className="text-green-400 font-bold">{c.correct.tag}</div><div className="text-xs text-gray-500">({c.correct.count} uses)</div></div></div><button onClick={() => fixTypo(c)} className="fluent-btn fluent-btn-primary">Fix</button></div>))}</div>
                            </div>
                        </div>
                    )}
                    {/* EXPORT MODAL */}
                    {exportModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-md p-6">
                                <h2 className="text-xl font-bold text-white mb-4">Export Options</h2>
                                <div className="space-y-4 mb-6">
                                    <div className="bg-[#333] p-3 rounded">
                                        <div className="text-xs text-gray-400 font-bold uppercase mb-2">Filename</div>
                                        <input 
                                            className="fluent-input w-full" 
                                            placeholder="ZIP Name..." 
                                            value={exportOptions.customName} 
                                            onChange={e => setExportOptions({...exportOptions, customName: e.target.value})}
                                        />
                                    </div>
                                    <div className="bg-[#333] p-3 rounded"><div className="text-xs text-gray-400 font-bold uppercase mb-2">Image Format</div><div className="flex gap-2">{['original', 'png', 'jpeg'].map(fmt => (<button key={fmt} onClick={() => setExportOptions({...exportOptions, format: fmt})} className={`flex-1 py-1.5 rounded text-xs capitalize border ${exportOptions.format === fmt ? 'bg-[#0067c0] border-[#0067c0] text-white' : 'bg-[#2a2a2a] border-[#444] text-gray-400 hover:border-gray-500'}`}>{fmt}</button>))}</div></div>
                                    <label className="flex items-center gap-3 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.buckets} onChange={e=>setExportOptions({...exportOptions, buckets: e.target.checked})} className="w-5 h-5"/><div><div className="font-bold text-white">Organize by Buckets</div><div className="text-xs text-gray-400">Folders by resolution</div></div></label>
                                    <label className="flex items-center gap-3 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.stats} onChange={e=>setExportOptions({...exportOptions, stats: e.target.checked})} className="w-5 h-5"/><div><div className="font-bold text-white">Include JSON Report</div><div className="text-xs text-gray-400">Statistics file</div></div></label>
                                    <div className="flex gap-2"><label className="flex-1 flex items-center gap-2 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.images} onChange={e=>setExportOptions({...exportOptions, images: e.target.checked})} className="w-4 h-4"/> <span className="text-white">Images</span></label><label className="flex-1 flex items-center gap-2 p-3 bg-[#333] rounded cursor-pointer hover:bg-[#3a3a3a]"><input type="checkbox" checked={exportOptions.text} onChange={e=>setExportOptions({...exportOptions, text: e.target.checked})} className="w-4 h-4"/> <span className="text-white">Text files</span></label></div>
                                    
                                    {isExporting && (
                                        <div className="mt-4">
                                            <div className="flex justify-between text-xs text-gray-400 mb-1">
                                                <span>Exporting...</span>
                                                <span>{exportProgress}%</span>
                                            </div>
                                            <div className="w-full h-2 bg-[#222] rounded-full overflow-hidden">
                                                <div className="h-full bg-[#0067c0] transition-all duration-300" style={{width: `${exportProgress}%`}}></div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                <div className="flex gap-2 justify-end">
                                    <button onClick={() => setExportModalOpen(false)} className="fluent-btn" disabled={isExporting}>Cancel</button>
                                    <button onClick={executeExport} className="fluent-btn fluent-btn-primary px-6" disabled={isExporting}>{isExporting ? 'Processing...' : 'Download ZIP'}</button>
                                </div>
                            </div>
                        </div>
                    )}
                    {/* BUCKET MODAL */}
                    {bucketModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-3xl flex flex-col max-h-[80vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="monitor" /> Resolutions</h2><button onClick={() => setBucketModalOpen(false)} className="fluent-btn">Close</button></div>
                                <div className="flex-1 overflow-y-auto p-4 space-y-2">{Object.entries(buckets).sort((a,b)=>b[1]-a[1]).map(([res, c]) => (<div key={res} className="flex items-center gap-4 text-sm"><div className="w-24 font-mono text-gray-300 text-right">{res}</div><div className="flex-1 bg-[#333] h-6 rounded overflow-hidden relative"><div className="bg-[#0067c0] h-full" style={{width: `${(c/files.length)*100}%`}}></div><span className="absolute inset-0 flex items-center pl-2 text-xs text-white">{c} img ({((c/files.length)*100).toFixed(1)}%)</span></div></div>))}</div>
                            </div>
                        </div>
                    )}
                    {/* OLD CONSOLIDATION MODAL */}
                    {consolidationModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8">
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl w-full max-w-4xl flex flex-col max-h-[85vh]">
                                <div className="p-4 border-b border-[#444] flex justify-between items-center bg-[#202020] rounded-t-lg"><div><h2 className="text-lg font-bold text-white flex items-center gap-2"><Icon name="puzzle" /> Consolidation</h2></div><div className="flex gap-2"><button onClick={applyConsolidation} className="fluent-btn fluent-btn-primary">Save</button><button onClick={() => setConsolidationModalOpen(false)} className="fluent-btn">Cancel</button></div></div>
                                <div className="flex-1 overflow-y-auto p-4"><div className="grid grid-cols-2 md:grid-cols-3 gap-3">{tagStats.map(({ tag, count }) => (<div key={tag} className="bg-[#333] p-2 rounded flex flex-col gap-1 border border-[#444]"><div className="flex justify-between text-xs text-gray-400 mb-1"><span>Original: {tag}</span><span className="bg-[#222] px-1.5 rounded">{count}</span></div><input className="fluent-input text-xs" defaultValue={tag} onChange={(e) => handleTagEditChange(tag, e.target.value)}/></div>))}</div></div>
                            </div>
                        </div>
                    )}
                    
                    {/* ABOUT MODAL */}
                    {aboutModalOpen && (
                        <div className="fixed inset-0 modal-overlay flex items-center justify-center p-8" onClick={() => setAboutModalOpen(false)}>
                            <div className="bg-[#252525] border border-[#444] rounded-lg shadow-2xl p-6 w-full max-w-sm text-center relative" onClick={e => e.stopPropagation()}>
                                <button onClick={() => setAboutModalOpen(false)} className="absolute top-2 right-2 text-gray-400 hover:text-white"><Icon name="x" size={20}/></button>
                                <div className="mb-4 flex justify-center">
                                    <div className="w-16 h-16 bg-[#0067c0] rounded-xl flex items-center justify-center">
                                        <Icon name="box" size={32} className="text-white"/>
                                    </div>
                                </div>
                                <h2 className="text-2xl font-bold text-white mb-1">Dataset Studio</h2>
                                <p className="text-sm text-[#0067c0] font-bold mb-4">Aiiko Labs</p>
                                <div className="text-gray-400 text-sm space-y-2 mb-6">
                                    <p>Version 2.6 (Global Edition)</p>
                                    <p>Professional tool for LoRa/SD dataset curation and management.</p>
                                </div>
                                <div className="border-t border-[#444] pt-4">
                                    <p className="text-xs text-gray-500">Developed by</p>
                                    <p className="text-white font-bold">Hirayama Aiiko</p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ErrorBoundary><App /></ErrorBoundary>);
    </script>
</body>
</html>
